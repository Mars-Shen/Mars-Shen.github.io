<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何在IOS中实现可折叠/展开的Table Section</title>
    <url>/posts/95d092ba/</url>
    <content><![CDATA[<p><img src="https://img.shields.io/badge/Swift-2.2-orange.svg?style=flat"></p>
<blockquote>
<p>原文链接以及源代码:<a href="https://github.com/jeantimex/ios-swift-collapsible-table-section">原文地址</a><br/>原文作者:Yong Su @ Box Inc.</p>
</blockquote>
<h1 id="如何在IOS中实现可折叠-x2F-展开的Table-Section"><a href="#如何在IOS中实现可折叠-x2F-展开的Table-Section" class="headerlink" title="如何在IOS中实现可折叠&#x2F;展开的Table Section?!"></a>如何在IOS中实现可折叠&#x2F;展开的Table Section?!</h1><p><img src="/img/IOSection/demo.gif" alt="Demo效果"></p>
<span id="more"></span>

<h4 id="第一步-准备数据"><a href="#第一步-准备数据" class="headerlink" title="第一步:准备数据"></a>第一步:准备数据</h4><p>
假设我们有下面这些分好组的数据,每一组是一个 <code>Section</code> 对象
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Section</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span>!</span><br><span class="line">  <span class="keyword">var</span> items: [<span class="type">String</span>]<span class="operator">!</span></span><br><span class="line">  <span class="keyword">var</span> collapsed: <span class="type">Bool</span>!</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">items</span>: [<span class="type">String</span>], <span class="params">collapsed</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.items <span class="operator">=</span> items</span><br><span class="line">    <span class="keyword">self</span>.collapsed <span class="operator">=</span> collapsed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sections <span class="operator">=</span> [<span class="type">Section</span>]()</span><br><span class="line"></span><br><span class="line">sections <span class="operator">=</span> [</span><br><span class="line">  <span class="type">Section</span>(name: <span class="string">&quot;Mac&quot;</span>, items: [<span class="string">&quot;MacBook&quot;</span>, <span class="string">&quot;MacBook Air&quot;</span>, <span class="string">&quot;MacBook Pro&quot;</span>, <span class="string">&quot;iMac&quot;</span>, <span class="string">&quot;Mac Pro&quot;</span>, <span class="string">&quot;Mac mini&quot;</span>, <span class="string">&quot;Accessories&quot;</span>, <span class="string">&quot;OS X El Capitan&quot;</span>]),</span><br><span class="line">  <span class="type">Section</span>(name: <span class="string">&quot;iPad&quot;</span>, items: [<span class="string">&quot;iPad Pro&quot;</span>, <span class="string">&quot;iPad Air 2&quot;</span>, <span class="string">&quot;iPad mini 4&quot;</span>, <span class="string">&quot;Accessories&quot;</span>]),</span><br><span class="line">  <span class="type">Section</span>(name: <span class="string">&quot;iPhone&quot;</span>, items: [<span class="string">&quot;iPhone 6s&quot;</span>, <span class="string">&quot;iPhone 6&quot;</span>, <span class="string">&quot;iPhone SE&quot;</span>, <span class="string">&quot;Accessories&quot;</span>])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<code>collapsed</code> 表明了现在是否是折叠状态,默认为false.
</p>

<h4 id="第二步-设计-Header-和-Cell"><a href="#第二步-设计-Header-和-Cell" class="headerlink" title="第二步:设计 Header 和 Cell"></a>第二步:设计 Header 和 Cell</h4><p>在story board中选择 <code>Table View</code>, 选择 <code>Dynamic Prototypes</code>并且设置 <code>Prototype Cells</code> 的值为 2, 一个给我们的自定义 Header,另外一个给我们每一行的 Cell, 然后将各自的 <code>Identifier</code> 设置为为 header 和 cell.</p>
![](/img/IOSection/cell.png)
<p>添加一个 UIButton (用做切换折叠状态) 和一个 Label 到 header 的 prototype cell 中, 创建一个继承自 <code>UITableViewCell</code> 的 swift 文件并且命名为<code> CollapsibleTableViewHeader.swift</code>. 这个文件很简单, 有两个 IBOutlets, 一个用做链接切换按钮 (UIButton), 另外一个用做链接 Label. 最后我们设置这个 header 的 Class 为 我们自定义的类 <code>CollapsibleTableViewHeader</code> 并且在类中正确的链接 IBOutlets.</p>
<p>现在这个文件应该看起来像这样:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollapsibleTableViewHeader</span>: <span class="title class_">UITableViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@IBOutlet</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel</span>!</span><br><span class="line">  <span class="keyword">@IBOutlet</span> <span class="keyword">var</span> toggleButton: <span class="type">UIButton</span>!</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个 prototype cell 和一个继承自 UITableViewCell 的类, 有这两点好处:</p>
<ul>
<li>我们能可视化的设计我们的 header</li>
<li>我们不需要像这样为了创建一个 Cell 而创建一个 nib 文件 然后在 tableView 中注册他使用:</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nib <span class="operator">=</span> <span class="type">UINib</span>(nibName: <span class="string">&quot;TableSectionHeader&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">tableView.registerNib(nib, forHeaderFooterViewReuseIdentifier: <span class="string">&quot;TableSectionHeader&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>个人而言, 我不喜欢在我的项目中有 nib 文件, 并且如果我们用了 <code>dequeueReusableHeaderFooterViewWithIdentifier</code>, 好像我们必须在那个 section 中最少拥有一行 row, 但这里我们需要 0 row!</p>

<h4 id="第三步-UITableViewDelegate"><a href="#第三步-UITableViewDelegate" class="headerlink" title="第三步: UITableViewDelegate"></a>第三步: UITableViewDelegate</h4><p>首先,用 sections.count 正确的表示 section 的数量:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">numberOfSectionsInTableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sections.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于那些每个 section 中的 row 的数量, 我们使用 <code>collapsed</code> 变量去控制它, 如果 collapsed 是 true, 我们就返回 0, 否则返回他真实 items 的数量:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">numberOfRowsInSection</span> <span class="params">section</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (sections[section].collapsed<span class="operator">!</span>) <span class="operator">?</span> <span class="number">0</span> : sections[section].items.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 tableView 的 viewForHeaderInSection 方法去实现我们自定义的 header:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">viewForHeaderInSection</span> <span class="params">section</span>: <span class="type">Int</span>) -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line">  <span class="keyword">let</span> header <span class="operator">=</span> tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;header&quot;</span>) <span class="keyword">as!</span> <span class="type">CollapsibleTableViewHeader</span></span><br><span class="line"></span><br><span class="line">  header.titleLabel.text <span class="operator">=</span> sections[section].name</span><br><span class="line">  header.toggleButton.tag <span class="operator">=</span> section</span><br><span class="line">  header.toggleButton.addTarget(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(<span class="type">CollapsibleTableViewController</span>.toggleCollapse), forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line"></span><br><span class="line">  header.toggleButton.rotate(sections[section].collapsed<span class="operator">!</span> <span class="operator">?</span> <span class="number">0.0</span> : <span class="type">CGFloat</span>(<span class="type">M_PI_2</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> header.contentView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们为我们的接切换按钮 (UIButton) 注册了一个touch up inside 事件, 一旦这个按钮被按下, 它将会触发 toggleCollapse 方法.</p>
<p>最后, 我们的 row cell 看起来像这样:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">cellForRowAtIndexPath</span> <span class="params">indexPath</span>: <span class="type">NSIndexPath</span>) -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cell <span class="operator">=</span> tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;cell&quot;</span>) <span class="keyword">as</span> <span class="type">UITableViewCell</span>!</span><br><span class="line"></span><br><span class="line">  cell.textLabel<span class="operator">?</span>.text <span class="operator">=</span> sections[indexPath.section].items[indexPath.row]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是 toggleCollapse 方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">toggleCollapse</span>(<span class="params">sender</span>: <span class="type">UIButton</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> section <span class="operator">=</span> sender.tag</span><br><span class="line">  <span class="keyword">let</span> collapsed <span class="operator">=</span> sections[section].collapsed</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Toggle collapse</span></span><br><span class="line">  sections[section].collapsed <span class="operator">=</span> <span class="operator">!</span>collapsed</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reload section</span></span><br><span class="line">  tableView.reloadSections(<span class="type">NSIndexSet</span>(index: section), withRowAnimation: .<span class="type">Automatic</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好啦,就是这么简单,如果你需要看源代码,请到顶部原文链接中,你可以在那个链接中找到具体的实现代码</p>

<p><b>更多的可折叠Demo</b></p>
<p>有时你可能要在grouped-style table中实现一些可折叠的cells, 我有一些单独的Demo在<a href="https://github.com/jeantimex/ios-swift-collapsible-table-section-in-grouped-section">链接</a>中. 他的实现和今天我们学的这个非常相似,只有一点点小不同,如果有兴趣可以去看下.</p>

<p><img src="/img/IOSection/otherDemo.gif" alt="排序效果"></p>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>翻译</tag>
        <tag>互联网技术</tag>
        <tag>IOS开发</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot/Mybatis/Dubbo/Druid整合</title>
    <url>/posts/34fb554c/</url>
    <content><![CDATA[<blockquote>记录自己项目中使用Spring Boot与Mybatis/Dubbo/Druid整合过程中出现的问题,以及相应的解决方法.</blockquote>

<h1 id="Spring-Boot部分"><a href="#Spring-Boot部分" class="headerlink" title="Spring Boot部分"></a>Spring Boot部分</h1><h4 id="生成一个简单的Spring-Boot项目"><a href="#生成一个简单的Spring-Boot项目" class="headerlink" title="生成一个简单的Spring Boot项目"></a>生成一个简单的Spring Boot项目</h4><p>首先去Spring Boot的官网项目生成器生成一个简单项目:<code><a href="https://start.spring.io/">start.spring.io</a></code><br><img src="/img/SpringBoot/SpringBoot-1.png"><br>点Generate Project下载并且导入到本地IDE, 这里用的是Intellij.</p>
<h4 id="Spring-Boot-Pom文件修改默认继承关系及引用"><a href="#Spring-Boot-Pom文件修改默认继承关系及引用" class="headerlink" title="Spring Boot Pom文件修改默认继承关系及引用"></a>Spring Boot Pom文件修改默认继承关系及引用</h4><p>
    默认Pom文件Spring Boot是用继承Pom的方式导入Spring Boot的必须组件的,那如果项目Pom中本来就已经有一个<code>parent</code>存在了,那应该怎么办呢? Spring Boot给出了自己的解决办法
</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>
    使用<code>dependencyManagement</code>代替<code>parent</code>完成Spring Boot必须组件的导入.
</p>

<h4 id="出现错误"><a href="#出现错误" class="headerlink" title="出现错误"></a>出现错误</h4><p>
    项目中出现:
</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation (class org.slf4j.log4j12.Log4jLoggerFactory loaded from file:/Users/MarsShen/Project/SSM/xmall/xmall-manager/xmall-manager-service-springboot/target/xmall-manager-service-springboot-0.0.1-SNAPSHOT/WEB-INF/lib/slf4j-log4j12-1.8.0-alpha2.jar). If you are using WebLogic you will need to add &#x27;org.slf4j&#x27; to prefer-application-packages in WEB-INF/weblogic.xml: org.slf4j.log4j12.Log4jLoggerFactory</span><br><span class="line">	at org.springframework.util.Assert.instanceCheckFailed(Assert.java:637)</span><br><span class="line">	at org.springframework.util.Assert.isInstanceOf(Assert.java:537)</span><br><span class="line">	at org.springframework.boot.logging.logback.LogbackLoggingSystem.getLoggerContext(LogbackLoggingSystem.java:274)</span><br><span class="line">	at org.springframework.boot.logging.logback.LogbackLoggingSystem.beforeInitialize(LogbackLoggingSystem.java:99)</span><br><span class="line">	at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationStartingEvent(LoggingApplicationListener.java:191)</span><br><span class="line">	at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEvent(LoggingApplicationListener.java:170)</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127)</span><br><span class="line">	at org.springframework.boot.context.event.EventPublishingRunListener.starting(EventPublishingRunListener.java:68)</span><br><span class="line">	at org.springframework.boot.SpringApplicationRunListeners.starting(SpringApplicationRunListeners.java:48)</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:313)</span><br><span class="line">	at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:155)</span><br><span class="line">	at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:135)</span><br><span class="line">	at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:87)</span><br><span class="line">	at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:172)</span><br><span class="line">	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5196)</span><br><span class="line">	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)</span><br><span class="line">	... 43 more</span><br></pre></td></tr></table></figure>

<p>这是由于项目中已经存在log4j的jar包,与Logback产生冲突导致运行时出现这个<code>java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath.</code>错误. 通过<code>mvn dependency:tree</code>命令可以看到具体冲突的文件<br><img src="/img/SpringBoot/SpringBoot-2.png"><br>解决这个问题很简单, 只需要在Spring Boot组件导入的时候, 将有冲突的组件排除<code>spring-boot-starter-logging</code>再导入即可.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Spring-Boot与Dubbo整合"><a href="#Spring-Boot与Dubbo整合" class="headerlink" title="Spring Boot与Dubbo整合"></a>Spring Boot与Dubbo整合</h1><h4 id="Spring-Boot与Dubbo整合-1"><a href="#Spring-Boot与Dubbo整合-1" class="headerlink" title="Spring Boot与Dubbo整合"></a>Spring Boot与Dubbo整合</h4><p>
    Spring Boot与Dubbo整合相对比较简单, 首先在Pom文件中导入相应的jar包:
</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dubbo.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>
    修改application.properties中的配置, 添加dubbo相关属性:
</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#Dubbo 服务提供者配置</span><br><span class="line">#注册中心选择了zookeeper</span><br><span class="line">spring.dubbo.registry.address=zookeeper://127.0.0.1:2181 </span><br><span class="line">spring.dubbo.protocol.name=dubbo </span><br><span class="line">spring.dubbo.protocol.port=20880</span><br><span class="line">spring.dubbo.application.name=provider</span><br><span class="line">#需要暴露接口的包</span><br><span class="line">spring.dubbo.scan=cn.example.servicespringboot.service.imp</span><br></pre></td></tr></table></figure>
<p>
    最后在服务生产者类中使用<code>com.alibaba.dubbo.config.annotation.Service</code>中的<code>@service</code>即可暴露service
</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MemberService</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dubbo-Admin的使用"><a href="#Dubbo-Admin的使用" class="headerlink" title="Dubbo Admin的使用"></a>Dubbo Admin的使用</h4><p>
    Dubbo控制台可以很好的监控当前服务发布者与消费者的状态, 建议调试的时候安装使用.<code><a href="http://dubbo.io/books/dubbo-admin-book/">安装教程</a></code>
</p>

<h1 id="Spring-Boot与Mybatis-x2F-Druid整合"><a href="#Spring-Boot与Mybatis-x2F-Druid整合" class="headerlink" title="Spring Boot与Mybatis&#x2F;Druid整合"></a>Spring Boot与Mybatis&#x2F;Druid整合</h1><h4 id="Spring-Boot与Mybatis-x2F-Druid整合-1"><a href="#Spring-Boot与Mybatis-x2F-Druid整合-1" class="headerlink" title="Spring Boot与Mybatis&#x2F;Druid整合"></a>Spring Boot与Mybatis&#x2F;Druid整合</h4><p>
    首先在Pom文件中导入相应的jar包:
</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>            </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>
    修改application.properties中的配置, 使用Druid链接数据库:
</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#数据库设置</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource  </span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver  </span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf-8</span><br><span class="line">spring.datasource.username=root  </span><br><span class="line">spring.datasource.password=root  </span><br><span class="line">#--------------------------</span><br><span class="line"># 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line"># 初始化大小，最小，最大</span><br><span class="line">spring.datasource.initialSize=5  </span><br><span class="line">spring.datasource.minIdle=5  </span><br><span class="line">spring.datasource.maxActive=20  </span><br><span class="line"># 配置获取连接等待超时的时间</span><br><span class="line">spring.datasource.maxWait=60000  </span><br><span class="line"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">spring.datasource.timeBetweenEvictionRunsMillis=60000  </span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">spring.datasource.minEvictableIdleTimeMillis=300000  </span><br><span class="line">spring.datasource.validationQuery=SELECT 1 FROM DUAL  </span><br><span class="line">spring.datasource.testWhileIdle=true  </span><br><span class="line">spring.datasource.testOnBorrow=false  </span><br><span class="line">spring.datasource.testOnReturn=false  </span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">spring.datasource.poolPreparedStatements=true  </span><br><span class="line">spring.datasource.maxPoolPreparedStatementPerConnectionSize=20  </span><br><span class="line"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span><br><span class="line">spring.datasource.filters=stat,wall,log4j  </span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000  </span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">#spring.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure>
<p>
    创建一个用DatasourceConfig类来配置Data source:
</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.example.servicespringboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatasourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">druidDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>
    在启动类中加入<code>@ServletComponentScan</code>和<code>@MapperScan("cn.example.manager.mapper")</code>:定义mapper所在的包
</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.example.manager.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceSpringbootApplication</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>
    至此, 整个整合基本就配置完成.
</p>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>互联网技术</tag>
        <tag>Spring Boot</tag>
        <tag>Mybatis</tag>
        <tag>Dubbo</tag>
        <tag>Druid</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用MetaMask钱包完成EOS钱包映射</title>
    <url>/posts/8a7a7578/</url>
    <content><![CDATA[<blockquote>前提条件:
    <ul>
        <li>科学上网</li>
        <li>Chrome浏览器</li>
    </ul>
</blockquote>

<h1 id="是否需要钱包映射"><a href="#是否需要钱包映射" class="headerlink" title="是否需要钱包映射?"></a>是否需要钱包映射?</h1><p>
    关于是否需要映射的问题, 网上已经有很多讨论了, 个人在这里给出的建议是, 如果你嫌麻烦可以直接把EOS放在交易所, 据我所知现在主流的交易所都会帮你完成映射过程, 但如果你想把交易所的EOS提出来保存到自己的钱包, 那还是需要做钱包映射的, 因为EOS项目目前还没有完成, 目前市场上的EOS为项目开发组预发行的EOS代币, 并不是真正的EOS币, 在2018年6月2日6:59:59（北京时间）此前钱包里流通的EOS代币将会被冻结, 真正的EOS币将会投放到对应钱包取代这些代币, 如果钱包不做映射, 你将不会得到这些真正的EOS货币.
</p>

<h1 id="使用MetaMask钱包完成EOS钱包映射"><a href="#使用MetaMask钱包完成EOS钱包映射" class="headerlink" title="使用MetaMask钱包完成EOS钱包映射"></a>使用MetaMask钱包完成EOS钱包映射</h1><blockquote>映射分三步:
    <ul>
        <li>钱包的生成</li>
        <li>EOS公钥私钥的生成</li>
        <li>签署智能合约, 完成映射</li>
    </ul>
</blockquote>
<span id="more"></span>
<p>
    网上关于使用MyEtherWallet完成钱包映射的文章有很多, 但是使用MetaMask钱包完成EOS钱包映射的文章却不多, 本文主要介绍使用MetaMask钱包完成EOS钱包映射. MetaMask钱包是Chrome的一个插件, 非常方便, 同时也是EOS官网推荐的钱包之一. 映射过程比MyEtherWallet方便很多.
</p>

<h4 id="安装MetaMask钱包插件-生成钱包"><a href="#安装MetaMask钱包插件-生成钱包" class="headerlink" title="安装MetaMask钱包插件, 生成钱包"></a>安装MetaMask钱包插件, 生成钱包</h4><p>
    这一步很简单, 首先在Chrome插件中心搜索MetaMask并且安装. 
</p>

<p><img src="/img/EOSMapping/metamask.png"></p>
<p>
    打开这个插件. 点击接受协议, 第二次协议出现时, 需要将协议滚到最下面接受按钮才会亮:
</p>

<p><img src="/img/EOSMapping/metamaskstep1.png"></p>
<p>
    创建一个新密码, 这个密码是用来登陆本地钱包账户的, 请牢记:
</p>

<p><img src="/img/EOSMapping/metamaskstep2.png"></p>
<p>
    他会给你12个英文单词, 找个安全的地方记好这12个单词, 因为这是唯一恢复你钱包的方法, 完了之后点击<code>I'VE COPIED IT SOMEWHERE SAFE</code>进入下一步:
</p>

<p><img src="/img/EOSMapping/metamaskstep3.png"></p>
<p>
    至此钱包部分就已经完成了, 你可以自己探索下这个钱包, 找到钱包的私钥保存好, 不要泄露.
</p>

<h4 id="EOS公钥私钥的生成"><a href="#EOS公钥私钥的生成" class="headerlink" title="EOS公钥私钥的生成"></a>EOS公钥私钥的生成</h4><p>
    这一步网上有很多工具可以一键生成EOS公钥和私钥, 但我没用过, 所以这里说的是官网生成方法, 首先进入EOS官网, 点击GOT. 注意这个按钮必须科学上网才能点, 因为EOS规定美国公民和中国公民无法参加这个EOS项目, 所以你得找个不是美国以及中国的ip才能点这个按钮.
</p>

<p><img src="/img/EOSMapping/geteos.png"></p>
<p>
    勾选所有选项, 进入下一页, 找到<code>Participation Instructions</code>选择<code>REGISTER</code>:
</p>

<p><img src="/img/EOSMapping/regbutton.png"></p>
<p>
    选择<code>METAMASK</code>, 打开你的Chrome MetaMask插件, 然后在网页上点击<code>EOS token distribution</code>按钮:
</p>

<p><img src="/img/EOSMapping/regmaskinfo.png"></p>
<p>
    这里页面上左边一栏从上到下分别是合约地址,你钱包的地址,以后映射完你EOS公钥的地址,EOS余额. 然后点击<code>REGISTER EOS KEY</code>按钮, 系统会生成一对新的EOS公钥和私钥, 请牢记你的公钥和私钥, 特别是私钥, 不要给别人, 自己妥善保管:
</p>

<p><img src="/img/EOSMapping/RegisterEOSkey.png"></p>
<p>
    妥善处置好你的私钥后, 将私钥填入确认框, 点击下一步:
</p>

<h4 id="签署智能合约-完成映射"><a href="#签署智能合约-完成映射" class="headerlink" title="签署智能合约, 完成映射"></a>签署智能合约, 完成映射</h4><p>
    当点击下一步以后, 系统会自动生成一个智能合约, 签署智能合约的过程就类似于一次交易, 需要一定的GAS, 也就是一定数量的ETH才能完成, 如果你没有ETH, 请先冲ETH进入你的钱包:
</p>

<p><img src="/img/EOSMapping/signcontract.png"></p>
<p>
    点击提交, 完成智能合约签署, 签署过程的时间由你给的GAS决定, 给的GAS越大, 处理起来越快, 我这里给了1GWEI, 处理了大概一晚上.
</p>
<p>
    如果想看进度, 可以点击MetaMask右上角三个点, 查看账户信息:
</p>

<p><img src="/img/EOSMapping/viewaccount.png"></p>
<p>
    这个页面可以看到详细的账户信息, 可以看到交易现在的状态:
</p>

<p><img src="/img/EOSMapping/accountinfo.png"></p>
<p>
    智能合约签署完成, 一般也就意味着映射的完成, 如何查看自己映射成功呢? 在刚才注册的网页, 也就是<code>EOS token distribution</code>页面上, 如果之前为空的EOS public key一项变成了你刚才生成的EOS公钥, 那就说明钱包与EOS公网已经完成映射.
</p>



<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/a9eae027/">自动化抢小米加密兔辅助工具</a></li><li><a href="https://stellarkey.github.io/%E6%8C%96%E7%9F%BF%E5%85%A5%E9%97%A8/">挖矿入门</a></li></ul></div>]]></content>
      <tags>
        <tag>EOS</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化抢小米加密兔辅助工具</title>
    <url>/posts/a9eae027/</url>
    <content><![CDATA[<h1 id="自动化抢小米加密兔辅助工具"><a href="#自动化抢小米加密兔辅助工具" class="headerlink" title="自动化抢小米加密兔辅助工具"></a>自动化抢小米加密兔辅助工具</h1><p>
小米区块链宠物小米加密兔领养活动目前第一阶段已经结束,请等待官方第二阶段消息. 该工具脚本用于实现自动化抢小米加密兔, 目前为可用状态(2018/4/2), 但并不能保证此脚本长期可用, 若有问题或者建议请在下面留言.
</p>

<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>使用前请先在Chrome下载Tampermonkey插件.</li>
<li>下载脚本文件XiaoMi-JiaMiTu-Tools.zip至本地.</li>
<li>将文件XiaoMi-JiaMiTu-Tools.zip导入Tampermonkey.</li>
<li>前往 <code><a href="https://jiamitu.mi.com/home">https://jiamitu.mi.com/home</a></code> 小米加密兔领养页面并登陆你自己的账号.</li>
<li>确保当前页面Tampermonkey中我们的脚本为开启状态. </li>
<li>当活动时间开始前1分钟点击<strong>开始抢加密兔</strong>,然后耐心等待脚本运行. 当页面提示你已抢到, 说明抢领成功, 如果长时间没领到加密兔, 可能加密兔已经被领完, 请第二天再尝试.</li>
<li>如果需要更新, 请在Tampermonkey插件更新插件.</li>
</ul>
<p>下载链接: <code><a href="https://github.com/Mars-Shen/XiaoMi-JiaMiTu-Tools/raw/master/XiaoMi-JiaMiTu-Tools.zip">点我下载</a></code><br>源码地址: <code><a href="https://github.com/Mars-Shen/XiaoMi-JiaMiTu-Tools">点我查看</a></code></p>
<span id="more"></span>

<h4 id="脚本原理"><a href="#脚本原理" class="headerlink" title="脚本原理"></a>脚本原理</h4><p>
脚本模拟用户点击, 运行时循环向小米服务器发用户送点击请求.
</p>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>活动开始时, 运行中脚本可能会卡住, 日志可能会不输出, 这是正常情况, 因为小米服务器在那一刻接受大量请求, 响应缓慢. 所以抢不抢的到兔子, 还是得看你运气, 这个脚本并不能保证你能抢到兔子, 只是起到辅助作用.</li>
<li>本脚本不会获取你的个人信息并且开源, 想了解具体信息请查看上面源码链接中代码.</li>
</ul>
<!-- 开启前效果:
<img src="/img/jiamitu/jiamitu-0.png" width="80%" heigh="80%"> -->
<p>开启后效果:<br><img src="/img/jiamitu/jiamitu-1.png" alt="开启后效果"></p>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li><li><a href="https://stellarkey.github.io/%E6%8C%96%E7%9F%BF%E5%85%A5%E9%97%A8/">挖矿入门</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Http劫持分析</title>
    <url>/posts/89408fe7/</url>
    <content><![CDATA[<h1 id="记一次Http劫持分析"><a href="#记一次Http劫持分析" class="headerlink" title="记一次Http劫持分析"></a>记一次Http劫持分析</h1><p>最近在家用手机访问我自己的博客的时候，无论我用什么手机浏览器总是会在第一次加载页面的时候，在页面上加载了各种奇怪的广告，我顿时觉得很疑惑，我什么时候在网站上放广告了？我是失忆了，还是我喝醉了？<br><img src="/img/HttpJieChi/blog-1.jpeg" alt="劫持效果"><br>看着这满屏的广告瞬间觉得很厌恶，本身很干净的网页像被贴了膏药一样的恶心，而且这些广告就像老鼠一般，一会有一会没有，神出鬼没。一看就是那些见不得光的人做出来的见不得光的事。愤怒过后，静下心来仔细分析了下，得出了一个结论: <code><b>我可能是被Http劫持了</b></code>。</p>
<span id="more"></span>

<h4 id="Http劫持"><a href="#Http劫持" class="headerlink" title="Http劫持"></a>Http劫持</h4><p>HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释“错误”的数据，并在使用者界面展示宣传性广告或者直接显示某网站的内容。以上内容来自百度百科，通俗点说就是<code><b>HTTP劫持就像是你开车去目的地的时候，半路经过了个过路站，有人开了你车门上车给你塞小广告，你带着小广告去了目的地。</b></code>没错，我给别人当了免费顺风车司机。</p>
<h4 id="谁在劫持我？"><a href="#谁在劫持我？" class="headerlink" title="谁在劫持我？"></a>谁在劫持我？</h4><p>那到底是谁在给我塞小广告呢？ 到这个时候我心中已经有三个怀疑对象:</p>
<ul>
<li>百度云加速</li>
<li>小米路由器</li>
<li>电信宽带运营商</li>
</ul>
<p>首先是百度云加速，为什么会想到他呢，因为这个网站在发生劫持的时候，用的正是百度云加速的DNS，理论上讲他有机会截取并修改我的Http内容。但我觉得他使坏的可能性不大，网上搜索的结果显示不出任何百度云加速会进行劫持的迹象，没有先例，虽然广告内容是百度百意的，但我觉得他应该只是个内容服务提供商，不会也没必要作恶做的那么明显，所以暂时先排除这一个可能。<br>剩下的就是路由器和运营商，这两个家伙都有很大可能进行Http劫持的，经过网上的搜索发现他们以前的所作所为，可谓劣迹斑斑。谷歌百度一搜一大片，小米15年的时候有个著名的<code>404Http劫持事件</code>，电信运营商的劣迹更是数不胜数，具体是谁看样子还得继续分析下去才能知道。</p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>通过Safari的代码分析得知，在网页的最下面，莫名其妙的被插入了<code>iframe</code>节点。这就是Http劫持做的好事！<br><img src="/img/HttpJieChi/blog-code-1.png" alt="劫持分析"><br>从代码中可以得知，可能是由百度提供了内容(cpu.baidu.com)，这个叫做<code>zmeng</code>的公司编写了插入的js。最后由路由器或者运营商执行了Http劫持，插入了代码。<br><img src="/img/HttpJieChi/blog-code-5.png" alt="劫持分析"><br>谷歌了一下这个cpu.baidu.com和zmeng(可能是众盟)，并没有得到什么特别有价值的信息。于是向下个网址入手。<code><a href="http://x.hao61.net/frqctrl.html">http://x.hao61.net/frqctrl.html</a></code><br><img src="/img/HttpJieChi/blog-code-2.png" alt="劫持分析"><br>从上面的图可以看出来这个<code>iframe</code>是由<code>zm.js:2029</code>初始化而来的，而这个zm.js是哪里来的呢？<br><img src="/img/HttpJieChi/blog-code-3.png" alt="劫持分析"><br>这个zm.js是从<code><a href="http://js.union-wifi.com/zm.js">http://js.union-wifi.com/zm.js</a></code>加载来的，这个看起来很像联通wifi的网址(并不是2333)，谷歌了一下发现又是个什么联盟的，没什么具体的信息，不过已经有人反映这个网址出现在别的网站Http劫持中，看起来有人和我同命相连了，遗憾的是他并没有具体的解决方法，我们只好继续往下看。<br><img src="/img/HttpJieChi/blog-code-4.png" alt="劫持分析"><br>最终我们追溯到源头了(并没有2333)。这个<code><a href="http://a.liuzhi520.com/">http://a.liuzhi520.com</a></code>下面的<code>rt_adjs_common.php</code>是一切js加载的源头，是初始化广告加载js的网址，同样谷歌之后没有有用的信息，线索到这里就断了。</p>
<h4 id="解决办法以及总结"><a href="#解决办法以及总结" class="headerlink" title="解决办法以及总结"></a>解决办法以及总结</h4><p>分析了一通，其实我并没有找到真正的源头，由于手上没有别的路由器(懒)，所以没有将小米路由器替换掉进行测试，但刚才谷歌<code>a.liuzhi520.com</code>的时候发现有人和我有一样的问题，<code><a href="http://www.cnblogs.com/cyq1162/p/6096283.html">这篇文章</a></code>讲述了他是怎么分析Http劫持的，至此我的分析更倾向于电信运营商在作怪。既然源头这么难找，那解决办法呢？解决办法还是有的！Http协议是明文传输的，本身的特点导致了他非常容易被劫持，最终，我将自己的网站改成<strong>全站强制Https访问</strong>，并且在家里路由中，<strong>将加载脚本的网址屏蔽</strong>。至此，这次Http劫持事件算是告一段落，但要根本的解决问题，我想还是要从运营商这个源头去处理这件事。在调查这次事件过程中，让我清楚的意识到Http网站是多么不安全以及容易被劫持，插小广告劫持还算好，万一劫持者插了一段JS，获取你当前在页面上输入的账户密码，理论上讲也是轻而易举的。总之如果各位以后遇到Http的页面，不管是开发还是普通的访问，都尽可能小心点吧。</p>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>互联网技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下Elasticsearch安装与问题记录</title>
    <url>/posts/2492827d/</url>
    <content><![CDATA[<h1 id="Ubuntu下Elasticsearch安装与问题记录"><a href="#Ubuntu下Elasticsearch安装与问题记录" class="headerlink" title="Ubuntu下Elasticsearch安装与问题记录"></a>Ubuntu下Elasticsearch安装与问题记录</h1><blockquote>
<p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力。 –&lt;&lt;Elasticsearch: 权威指南&gt;&gt;</p>
</blockquote>
<p>就像<code><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/preface.html">Elasticsearch: 权威指南</a></code>里说的，开源的 Elasticsearch是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。像维基百科、Stack Overflow、Github 等网站都采用它，足以见得他的能力。其实Elasticsearch最常见的组合是ELK(Elasticsearch + Logstash + kibana)，这里只介绍Elasticsearch的安装与使用。<br>本文的环境：Ubuntu。</p>
<h4 id="安装Elasticsearch注意事项"><a href="#安装Elasticsearch注意事项" class="headerlink" title="安装Elasticsearch注意事项"></a>安装Elasticsearch注意事项</h4><p>首先有一点要说明一下，ES对内存的要求很高，最好可以在内存2G以上的坏境运行Elasticsearch，否则可能会出现运行不稳定的问题。本人只有一台1核1G儿童云服务器，勉强使用中。另外ES运行需要Java8的运行环境，关于Java8的安装在这里不赘述，可以参考<code><a href="https://www.cnblogs.com/a2211009/p/4265225.html">这篇文章</a></code>。</p>
<h4 id="通过tar包安装Elasticsearch"><a href="#通过tar包安装Elasticsearch" class="headerlink" title="通过tar包安装Elasticsearch"></a>通过tar包安装Elasticsearch</h4><p>这里用当前最新版6.2.4做例子，最新版可以从<code><a href="https://www.elastic.co/cn/products/elasticsearch">Elasticsearch官网</a></code>找到。</p>
<span id="more"></span>
<p>首先通过curl下载tar包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压到当前目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf elasticsearch-6.2.4.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入当前目录，启动Elasticsearch：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd elasticsearch-6.2.4/bin</span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure>
<p>如果是用root账号启动，会报以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: don&#x27;t run elasticsearch as root. </span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:93) </span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:144) </span><br><span class="line">at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:285) </span><br><span class="line">at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35) </span><br><span class="line">Refer to the log for complete error details.</span><br></pre></td></tr></table></figure>
<p>这个意思也很明显，Elasticsearch出于安全方面的考虑， 不允许用户使用root账号启动Elasticsearch。我们得新建一个用户，专门用于启动Elasticsearch。</p>
<p>创建一个用户组elsearch与用户组中的用户elsearch：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd elsearch</span><br><span class="line">useradd elsearch -g elsearch</span><br></pre></td></tr></table></figure>
<p>修改用户elsearch的密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd elsearch</span><br></pre></td></tr></table></figure>
<p>修改目录拥有者，赋予相应的权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R elsearch:elsearch elasticsearch-6.2.4</span><br></pre></td></tr></table></figure>
<p>切换到用户elsearch，或者使用elsearch登陆，启动Elasticsearch：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su elsearch cd elasticsearch-6.2.4/bin</span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure>
<p>如果你想让你的ElasticSearch在后端启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch -d -p pid</span><br></pre></td></tr></table></figure>
<p>相应的Log信息可以在<code>$ES_HOME/logs/</code>中找到。如果想关了后台的这个Elasticsearch进程，只要执行如下命令就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill `cat pid`</span><br></pre></td></tr></table></figure>
<p>查看Elasticsearch是否安装成功，如果有返回值说明安装成功:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:9200</span><br></pre></td></tr></table></figure>

<h4 id="通过Docker安装Elasticsearch"><a href="#通过Docker安装Elasticsearch" class="headerlink" title="通过Docker安装Elasticsearch"></a>通过Docker安装Elasticsearch</h4><p>通过Docker来安装Elasticsearch的运行环境也是很好的一个选择，Docker可以快速的搭建我们所需要的环境，如果硬件条件允许，我觉得这个将是Elasticsearch环境搭建的首选。通过Docker的方式安装Elasticsearch前，请确保已经安装了Docker。</p>
<p><strong>安装步骤</strong></p>
<p>首先拉取Elasticsearch的Docker镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:6.2.4</span><br></pre></td></tr></table></figure>
<p>为了让我们能够方便的配置镜像中Elasticsearch的配置文件，我们可以用挂载配置文件的方式运行Elasticsearch镜像。</p>
<p>首先运行下载来的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; --rm --name es docker.elastic.co/elasticsearch/elasticsearch:6.2.4</span><br></pre></td></tr></table></figure>
<p>将镜像中的配置文件与Data文件夹拷贝到宿主主机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器name:/usr/share/elasticsearch/config /opt/elasticsearch/config/</span><br><span class="line">docker cp 容器name:/usr/share/elasticsearch/data /opt/elasticsearch/data/</span><br></pre></td></tr></table></figure>
<p>在宿主主机相应目录中修改相关配置如Elasticsearch.yml。</p>
<p>用挂载的宿主主机中的配置文件运行Elasticsearch的Docker镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 -d -e &quot;discovery.type=single-node&quot; --rm --name es -v /opt/elasticsearch/config:/usr/share/elasticsearch/config -v /opt/elasticsearch/data:/usr/share/elasticsearch/data docker.elastic.co/elasticsearch/elasticsearch:6.2.4</span><br></pre></td></tr></table></figure>
<p>因为加了<code>-d</code>，所以当前运行模式是后台运行，不会有什么输出，若要停止这个镜像的运行，输入<code>docker ps</code>查看相应的信息，根据相关信息使用<code>docker stop</code>命令，停止Elasticsearch服务。在上面的例子中我们使用<code>docker stop es</code>来停止Elasticsearch服务。</p>
<h4 id="安装Elasticsearch常见错误"><a href="#安装Elasticsearch常见错误" class="headerlink" title="安装Elasticsearch常见错误"></a>安装Elasticsearch常见错误</h4><p>这一部分部分引用<code><a href="https://github.com/DimonHo/DH_Note/issues/3">这篇文章</a></code>，结合我遇到的实际问题做了些修改。</p>
<p><strong>问题1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2017-04-13T00:14:20,144][WARN ][o.e.b.JNANatives ] unable to install syscall filter:</span><br><span class="line">java.lang.UnsupportedOperationException: seccomp unavailable: CONFIG_SECCOMP not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：报了一大串错误，大家不必惊慌，其实只是一个警告，主要是因为你Linux版本过低造成的。一般如果VPS为OpenVZ构架的很有可能出现这个问题，因为主机的内核一般都很低而且你没法升级内核，Elasticsearch推荐内核版本为3.10以上。</li>
<li>解决方案：<ol>
<li>重新安装新版本的Linux系统</li>
<li>警告不影响使用，可以忽略</li>
</ol>
</li>
</ul>
<p><strong>问题2：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2017-04-13T00:08:51,031][ERROR][o.e.b.Bootstrap ] [ZdbjA-a] node validation exception</span><br><span class="line">[4] bootstrap checks failed</span><br><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br><span class="line">[2]: max number of threads [1024] for user [es] is too low, increase to at least [2048]</span><br><span class="line">[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line">[4]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</span><br><span class="line">[2017-04-13T00:08:51,035][INFO ][o.e.n.Node ] [ZdbjA-a] stopping ...</span><br><span class="line">[2017-04-13T00:08:51,097][INFO ][o.e.n.Node ] [ZdbjA-a] stopped</span><br><span class="line">[2017-04-13T00:08:51,097][INFO ][o.e.n.Node ] [ZdbjA-a] closing ...</span><br><span class="line">[2017-04-13T00:08:51,107][INFO ][o.e.n.Node ] [ZdbjA-a] closed</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：如果你的VPS为OpenVZ构架，可以不用接着往下看了，因为你什么也做不了，所以买VPS推荐买KVM构架的，KVM构架更加独立，在你自己手上的控制权更多。</strong></p>
</blockquote>
<p>这里报了若干个错误，我们一个一个来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：无法创建本地文件问题，用户最大可创建文件数太小</li>
<li>解决方案：<ol>
<li>切换到root用户，编辑limits.conf配置文件，运行：<code>vi /etc/security/limits.conf</code>添加如下内容(备注：* 代表Linux所有用户名称（比如 hadoop）保存、退出、重新登录才可生效。)：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">max number of threads [1024] for user [es] is too low, increase to at least [2048]</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：无法创建本地线程问题,用户最大可创建线程数太小</li>
<li>解决方案：<br>  1.切换到root用户，进入limits.d目录下，修改90-nproc.conf 配置文件。<code>vi /etc/security/limits.d/90-nproc.conf</code>找到如下内容：<br><code>* soft nproc 1024</code>修改为：<code>* soft nproc 2048</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：这个问题比较常见，原因是因为最大虚拟内存太小<ol>
<li>解决方案：切换到root用户下，修改配置文件sysctl.conf，<code>vi /etc/sysctl.conf</code>添加下面配置：<br><code>vm.max_map_count=655360</code>，并执行命令：<code>sysctl -p</code>，然后重新启动Elasticsearch，即可启动成功。</li>
</ol>
</li>
</ul>
<p><strong>问题3：</strong></p>
<p>启动后，如果只有本地可以访问，尝试修改配置文件 elasticsearch.yml中network.host(注意配置文件格式不是以 # 开头的要空一格， ： 后要空一格)为<br><code>network.host: 0.0.0.0</code>，默认端口是 9200，注意：关闭防火墙 或者开放9200端口。</p>
<p><strong>问题4：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Java HotSpot(TM) Client VM warning: INFO: os::commit_memory(0x74800000, 201326592, 0) failed; error=&#x27;Cannot allocate memory&#x27; (errno=12)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># There is insufficient memory for the Java Runtime Environment to continue.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Native memory allocation (malloc) failed to allocate 201326592 bytes <span class="keyword">for</span> committing reserved memory.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原因：这个错误是由于Elasticsearch尝试用默认配置的2G内存启动（Elasticsearch 5.X以后的版本），但你的机器实际内存小于2G导致的内存不足问题。</li>
<li>解决方案二选一即可：<ol>
<li>升级你机器的内存。</li>
<li>修改Elasticsearch中jvm的配置，即修改<code>elasticsearch-6.2.4/config/</code>中的jvm.options文件。修改其中的<code>-Xms2g -Xmx2g</code>为<code>-Xms512m -Xmx512m</code>即可。注意这个参数可能需要根据具体情况具体设置，但有个原则就是<code>-Xms</code>与<code>-Xmx</code>需要相等。</li>
</ol>
</li>
</ul>
<h4 id="安装elasticsearch-head插件"><a href="#安装elasticsearch-head插件" class="headerlink" title="安装elasticsearch-head插件"></a>安装elasticsearch-head插件</h4><p>elasticsearch-head是个用来与Elasticsearch互动的图形化界面插件，有了他你可以很方便的管理你的Elasticsearch，查看你的Elasticsearch状态或者测试你的查询语句。这个是他官方的<code><a href="https://github.com/mobz/elasticsearch-head">GitHub页面</a></code>。</p>
<p><strong>安装步骤：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p>安装完成后用<a href="http://localhost:9100/">http://localhost:9100/</a> 打开即可。</p>
<blockquote>
<p>elasticsearch-head也推出了Chrome插件，<strong>个人推荐直接安装Chrome的插件来使用elasticsearch-head</strong>，非常非常方便。</p>
</blockquote>
<h4 id="安装elasticsearch-analysis-ik插件"><a href="#安装elasticsearch-analysis-ik插件" class="headerlink" title="安装elasticsearch-analysis-ik插件"></a>安装elasticsearch-analysis-ik插件</h4><p>elasticsearch-analysis-ik是一个Elasticsearch的中文分词插件，支持自定义词库以及热更新，这个是他官方的<code><a href="https://github.com/medcl/elasticsearch-analysis-ik">GitHub页面</a></code>。</p>
<p><strong>安装步骤：</strong></p>
<p>方式一：</p>
<p>从<code><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">这里</a></code>下载你Elasticsearch相应版本的安装包，解压缩后放在<code>your-es-root/plugins/</code>中。</p>
<p>方式二：</p>
<p>使用Elasticsearch-plugin来安装，这个方式支持v5.5.1以后的版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.3/elasticsearch-analysis-ik-6.2.3.zip</span><br></pre></td></tr></table></figure>
<p>注意将6.2.3换成你自己Elasticsearch所用的版本，安装完成后重启Elasticsearch服务。</p>
<p><strong>如何使用：</strong></p>
<p>首先创建一个index：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XPUT http://localhost:9200/index</span><br></pre></td></tr></table></figure>
<p>然后创建mapping：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/index/fulltext/_mapping -H &#x27;Content-Type:application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;content&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">                &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>之后就像往常一样，创建doc并且查询这个中文字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/index/fulltext/1 -H &#x27;Content-Type:application/json&#x27; -d&#x27;</span><br><span class="line">&#123;&quot;content&quot;:&quot;美国留给伊拉克的是个烂摊子吗&quot;&#125;</span><br><span class="line">&#x27;</span><br><span class="line">curl -XPOST http://localhost:9200/index/fulltext/2 -H &#x27;Content-Type:application/json&#x27; -d&#x27;</span><br><span class="line">&#123;&quot;content&quot;:&quot;公安部：各地校车将享最高路权&quot;&#125;</span><br><span class="line">&#x27;</span><br><span class="line">curl -XPOST http://localhost:9200/index/fulltext/3 -H &#x27;Content-Type:application/json&#x27; -d&#x27;</span><br><span class="line">&#123;&quot;content&quot;:&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;&#125;</span><br><span class="line">&#x27;</span><br><span class="line">curl -XPOST http://localhost:9200/index/fulltext/4 -H &#x27;Content-Type:application/json&#x27; -d&#x27;</span><br><span class="line">&#123;&quot;content&quot;:&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;&#125;</span><br><span class="line">&#x27;</span><br><span class="line">curl -XPOST http://localhost:9200/index/fulltext/_search  -H &#x27;Content-Type:application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;content&quot; : &quot;中国&quot; &#125;&#125;,</span><br><span class="line">    &quot;highlight&quot; : &#123;</span><br><span class="line">        &quot;pre_tags&quot; : [&quot;&lt;tag1&gt;&quot;, &quot;&lt;tag2&gt;&quot;],</span><br><span class="line">        &quot;post_tags&quot; : [&quot;&lt;/tag1&gt;&quot;, &quot;&lt;/tag2&gt;&quot;],</span><br><span class="line">        &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;content&quot; : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fulltext&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;&lt;tag1&gt;中国&lt;/tag1&gt;驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首 &quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fulltext&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;均每天扣1艘&lt;tag1&gt;中国&lt;/tag1&gt;渔船 &quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="安装x-pack插件"><a href="#安装x-pack插件" class="headerlink" title="安装x-pack插件"></a>安装x-pack插件</h4><p>x-pack是一个将各种插件集合起来的官方插件，这个插件集成了官方的Security（旧称 Shield），Alerting（通过 Watcher 实现），Monitoring（旧称 Marvel），Reporting，Graph，Machine Learning等。遗憾的是这个插件是付费的，如果只是自己学习用途，买个证书完全不合算。我们刚安装完Elasticsearch时，官方提供给我们一个试用licence，这是个全功能的证书，但是只能用30天。如果试用证书过期，官方另外提供了一种免费证书，类型为Basic，功能有限，具体可以看<code><a href="https://www.elastic.co/subscriptions/">这里</a></code>。x-pack我并不想详细讲，因为Basic证书连最基本的http认证都不提供，这表示如果将服务器暴露在外网环境任何人都可以随意操作我的Elasticsearch。最终我抛弃了x-pack并且通过Nginx的反向代理实现了最基本的http认证。</p>
<p>x-pack的介绍与安装步骤详细的信息可以看<code><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/installing-xpack-es.html">这里</a></code>。</p>
<p>证书相关操作可以看<code><a href="https://www.elastic.co/guide/en/x-pack/6.2/license-management.html">这里</a></code>。</p>
<p>Nginx相关设置可以看<code><a href="https://www.jianshu.com/p/7ec26c13abbb">这里</a></code></p>
<h4 id="资源列表"><a href="#资源列表" class="headerlink" title="资源列表"></a>资源列表</h4><ul>
<li><code><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/preface.html">Elasticsearch: 权威指南</a></code>， 这个是中文版的，容易看懂，但是有个问题就是版本有点老，最新版中已经移除type概念，这个指南中还存在这个概念，可以一看但更推荐看英文最新文档。</li>
<li><code><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">最新文档</a></code>，最新的英文文档，推荐阅读。</li>
</ul>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>互联网技术</tag>
        <tag>ELK</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下RabbitMQ的安装与配置</title>
    <url>/posts/4878be23/</url>
    <content><![CDATA[<h1 id="Ubuntu下RabbitMQ的安装与配置"><a href="#Ubuntu下RabbitMQ的安装与配置" class="headerlink" title="Ubuntu下RabbitMQ的安装与配置"></a>Ubuntu下RabbitMQ的安装与配置</h1><p>最近在研究RabbitMQ，本文简单记录了如何搭建与配置一个RabbitMQ服务器。</p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><p><code>rabbitmq-server</code>是可以在Ubuntu系统与Debian系统中使用的RabbitMQ服务器。在Ubuntu标准的repositories中，其实包含了<code>rabbitmq-server</code>，但是标准仓库中的版本往往非常的老旧，直接安装的话会得到的可能不是你想要的版本，所以想安装新版本，我们需要一些额外的工作。这里主要介绍了Ubuntu下通过<code>apt-get</code>的方法安装最新版本，如果想了解更多的安装方法，可以看<code><a href="https://www.rabbitmq.com/download.html">这里</a></code></p>
<p><strong>安装前提</strong></p>
<p>由于RabbitMQ需要基于Erlang&#x2F;OTP，所以在安装RabbitMQ之前需要先安装Erlang&#x2F;OTP。同样的，在Ubuntu标准的repositories中，Erlang&#x2F;OTP的版本很老，推荐不要直接安装在Ubuntu标准的repositories中Erlang&#x2F;OTP，而是安装新版本。</p>
<h4 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h4><p><strong>添加地址</strong></p>
<p>首先执行下面两个命令，添加Erlang自己的仓库地址到你本地。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb</span><br><span class="line">sudo dpkg -i erlang-solutions_1.0_all.deb</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>或者你可以手动添加仓库地址至本地。<br>添加下面代码至你本地<code>/etc/apt/sources.list</code>中，注意把下面的<code>&#123;distribution&#125;</code>(包括大括号)替换成你自己系统的distribution。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://packages.erlang-solutions.com/ubuntu &#123;distribution&#125; contrib</span><br></pre></td></tr></table></figure>
<p>如果不知道自己系统的distribution是什么，可以输入<code>lsb_release -c</code>查看，我自己的系统是Ubuntu16.04，对应的distribution是xenial，所以我添加进<code>/etc/apt/sources.list</code>的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://packages.erlang-solutions.com/ubuntu xenial contrib</span><br></pre></td></tr></table></figure>
<p>下一步用下面的命令来添加Erlang公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://packages.erlang-solutions.com/ubuntu/erlang_solutions.asc</span><br><span class="line">sudo apt-key add erlang_solutions.asc</span><br></pre></td></tr></table></figure>
<p><strong>开始安装Erlang</strong></p>
<p>用下面的命令刷新本地apt-get仓库的缓存，然后安装Erlang。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install erlang</span><br></pre></td></tr></table></figure>
<p>至此，Erlang安装完毕，如果想了解更多Erlang&#x2F;OTP的安装方法，可以看<code><a href="https://packages.erlang-solutions.com/erlang/#tabs-debian">这里</a></code></p>
<h4 id="安装rabbitmq-server"><a href="#安装rabbitmq-server" class="headerlink" title="安装rabbitmq-server"></a>安装rabbitmq-server</h4><p><strong>添加rabbitmq仓库地址</strong></p>
<p>同样的下面的像上文所说的一样将下面的<code>&#123;distribution&#125;</code>(包括大括号)替换成你自己系统的distribution。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb https://dl.bintray.com/rabbitmq/debian &#123;distribution&#125; main&quot; | sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list</span><br></pre></td></tr></table></figure>
<p>添加rabbitmq仓库公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O- https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>用下面的命令刷新本地apt-get仓库的缓存，然后安装rabbitmq-server。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>至此rabbitmq-server安装完毕。</p>
<h2 id="运行与配置RabbitMQ"><a href="#运行与配置RabbitMQ" class="headerlink" title="运行与配置RabbitMQ"></a>运行与配置RabbitMQ</h2><h4 id="运行RabbitMQ"><a href="#运行RabbitMQ" class="headerlink" title="运行RabbitMQ"></a>运行RabbitMQ</h4><p>在RabbitMQ安装包安装完后，服务器默认是会在后台通过一个没有特权的用户rabbitmq来运行的，想要手动启动或者停止重启服务器，只需要像系统中别的启动命令一样就可以了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure>

<h4 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h4><p>以下是官网上常用端口的介绍:</p>
<p><strong>4369</strong>: epmd, a peer discovery service used by RabbitMQ nodes and CLI tools <br><br><strong><code>5672, 5671</code></strong>: used by AMQP 0-9-1 and 1.0 clients without and with TLS <br><br><strong>25672</strong>: used for inter-node and CLI tools communication (Erlang distribution server port) and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). See networking guide for details. <br><br><strong>35672-35682</strong>: used by CLI tools (Erlang distribution client ports) for communication with nodes and is allocated from a dynamic range (computed as Erlang dist port + 10000 through dist port + 10010). See networking guide for details. <br><br><strong><code>15672</code></strong>: HTTP API clients and rabbitmqadmin (only if the management plugin is enabled) <br><br><strong>61613, 61614</strong>: STOMP clients without and with TLS (only if the STOMP plugin is enabled) <br><br><strong>1883, 8883</strong>: (MQTT clients without and with TLS, if the MQTT plugin is enabled <br><br><strong>15674</strong>: STOMP-over-WebSockets clients (only if the Web STOMP plugin is enabled) <br><br><strong>15675</strong>: MQTT-over-WebSockets clients (only if the Web MQTT plugin is enabled) <br></p>
<p>其中<code>5672, 5671</code>为消息队列常用的端口，<code>15672</code>为网页可视化管理所用的端口。</p>
<h4 id="开启网页可视化管理"><a href="#开启网页可视化管理" class="headerlink" title="开启网页可视化管理"></a>开启网页可视化管理</h4><p>开启网页可视化管理很简单，首先需要开启RabbitMQ可视化管理插件，通过如下命令开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>然后访问<code><a href="http://server-name:15672/">http://server-name:15672/</a></code>可以进入管理页面，默认账号密码都为<code>guest</code>，里面可以管理像创建用户，维护队列之类的功能，非常好用。<br>详细信息可以看<code><a href="https://www.rabbitmq.com/management.html">这里</a></code></p>
<p>完</p>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>互联网技术</tag>
        <tag>RabbitMQ</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>淘秀网架构与使用技术总览</title>
    <url>/posts/26b6aa29/</url>
    <content><![CDATA[<h1 id="淘秀网架构与使用技术总览"><a href="#淘秀网架构与使用技术总览" class="headerlink" title="淘秀网架构与使用技术总览"></a>淘秀网架构与使用技术总览</h1><blockquote>
<p>基于Elasticsearch&#x2F;SpringBoot&#x2F;Redis&#x2F;RabbitMQ&#x2F;Mybatis&#x2F;Dubbo&#x2F;Vue&#x2F;MySql，结合Scrapy爬虫数据挖掘的网站建设。</p>
</blockquote>
<p>最近在工作之余的时间，学习了一些新的技术，于是想做一个项目，用来巩固这些新技术。<a href="https://www.aitaoshow.com">淘秀网</a>就在这样的一个背景下诞生了，网站集成数据挖掘， 数据处理与展现于一身，其本身更像个搜索引擎。所有信息都是通过爬虫获取得到。<br>用户可以在网站上输入感兴趣的关键词，当用户输入一个关键词，网站展现出淘宝网中关键词相关产品的买家秀，用户可以通过查看买家秀的方式来决定是否购买当前产品，点击相应链接，前往淘宝网相关产品页面完成购买。</p>
<h3 id="构架"><a href="#构架" class="headerlink" title="构架"></a>构架</h3><ul>
<li><strong>数据端</strong><ul>
<li>Scrapy爬虫框架(Python)</li>
</ul>
</li>
<li><strong>数据库</strong><ul>
<li>Mysql</li>
</ul>
</li>
<li><strong>搜索服务器</strong><ul>
<li><a href="/2018/04/23/Elasticsearch-install-and-set-up/">Elasticsearch</a></li>
</ul>
</li>
<li><strong>后端服务</strong><ul>
<li>Spring Boot</li>
<li><a href="/2018/03/10/Spring+Boot+Mybatis+Dubbo+Druid/">Dubbo</a> </li>
<li>Redis</li>
<li><a href="/2018/05/05/RabbitMQ-install-and-set-up/">RabbitMQ 消息队列</a> </li>
<li>Mybatis-Plus</li>
<li>Druid</li>
<li>ZooKeeper 注册中心</li>
<li>Maven</li>
<li>Swagger2：Api文档生成</li>
</ul>
</li>
<li><strong>前端服务</strong><ul>
<li>Vue</li>
<li>element-ui<span id="more"></span>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><img src="/img/taoshow/taoshow_ architecture.JPG" width="100%" heigh="100%"></li>
</ul>
</li>
</ul>
<p>网站分为四个部分，三台服务器。其分别为后端数据获取部分，也就是上面的爬虫服务器 后端业务逻辑部分与前端展现部分, 也就是上面的业务服务器，搜索部分，也就是上面的搜索服务器。</p>
<ul>
<li><strong>后端数据获取部分</strong><br>后端数据获取部分主要由<code>Python</code>爬虫来完成，爬虫会根据相关关键字去获取目标网站相应的信息，取回信息后将信息存入数据库，同时也将数据存入搜索服务器以便后面后端业务的调用。</li>
<li><strong>后端业务逻辑部分</strong><br>这部分主要由<code>SpringBoot</code>以及相关技术组成，用来处理网站的业务逻辑，查询逻辑，关键词分析等。当用户输入一个关键词或者短语时，系统会从搜索服务器获取相关信息，返回给前端展现， 同时系统会对用户输入进行分词分析，提取更有效的关键词，当这个关键词不存在于我们系统中时候，系统将会通过队列异步调用数据获取部分（也就是爬虫部分）重新获取数据， 后端业务逻辑部分相当于整个网站的调度中心，拥有分析处理调度挖掘等功能。<br>同时也使用了<code>Dubbo</code>和<code>zookeeper</code>注册中心将api部分与业务实现部分分离，提高了后端的可扩展性与可维护性。使用<code>Redis</code>做缓存处理。</li>
<li><strong>前端展现部分</strong><br>这部分由现在比较流行的前端MVVM框架<code>Vue</code>来完成一个简单的搜索展现页面，配合<code>element-ui</code>可以达到一个较好的表现效果。</li>
<li><strong>搜索服务器部分</strong><br>使用了<code>Elasticsearch</code>作为我们的搜索服务器，目前看起来他的表现还是相当不错的。</li>
</ul>
<h4 id="关于关键词的处理"><a href="#关于关键词的处理" class="headerlink" title="关于关键词的处理"></a>关于关键词的处理</h4><p>当用户输入一个关键词或者短语时，无论这个关键词之前是否被爬虫执行过，系统都会先直接从搜索服务器获取相关信息，也就是说系统会先从以前存在的数据中找到相似的数据返回给用户，提升用户体验，与此同时如果这个关键词为新的关键词，系统将会通过队列去执行这个关键词相关信息的获取，下一次如果有别的用户或者这个用户过了一段时间回来输入类似的关键词，因为爬虫获取了相关数据，这个用户将看到更加丰富与完整的内容。</p>
<h4 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h4><p>大部分相关数据都用<code>Redis</code>进行缓存处理，包括空数据集，为了防止缓存穿透，对空数据集进行了短时间的缓存。同时对所有数据的过期时间也进行了加上随机数的处理，为了不让所有缓存同时过期，瞬时增加服务器负担。</p>
<h4 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h4><ul>
<li>查询时间过长(数据库优化与业务逻辑的优化)，随着数据的增长，这个为将越来越明显。</li>
<li>样式的优化(手机端更好的适配)</li>
</ul>
<h4 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h4><ul>
<li><a href="https://www.aitaoshow.com">淘秀网</a></li>
</ul>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>互联网技术</tag>
        <tag>淘秀网</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用RabbitMQ控制Scrapy爬虫</title>
    <url>/posts/39fb172e/</url>
    <content><![CDATA[<h1 id="如何使用RabbitMQ控制Scrapy爬虫"><a href="#如何使用RabbitMQ控制Scrapy爬虫" class="headerlink" title="如何使用RabbitMQ控制Scrapy爬虫"></a>如何使用RabbitMQ控制Scrapy爬虫</h1><blockquote>
<p>本文将介绍如何使用RabbitMQ整合Scrapy来控制Scrapy爬虫进行目标网页内容爬取。我们假设你已经使用过Scrapy和RabbitMQ或者对其有一定了解。</p>
</blockquote>
<h3 id="为什么要使用RabbitMQ来控制爬虫？"><a href="#为什么要使用RabbitMQ来控制爬虫？" class="headerlink" title="为什么要使用RabbitMQ来控制爬虫？"></a>为什么要使用RabbitMQ来控制爬虫？</h3><p>Scrapy爬虫其实有自己的一套生产环境部署控制系统<a href="https://github.com/scrapy/scrapyd">Scrapyd</a>，这是一个开源的项目，他给Scrapy提供了服务器端的HTTP API，使其拥有运行与监控Scrapy爬虫的能力，使用Scrapyd需要将我们的爬虫部署至Scrapyd服务器。</p>
<p>相比Scrapyd，RabbitMQ则多了一个队列的特性，同时也能监控与控制爬虫的，并且不需要将爬虫部署到特定的服务器，随时运行，同时与队列与我们整个项目的整合也更加平滑自如。目前<a href="https://www.marsshen.com/2018/05/23/Taoshow-website-Architecture-and-tech-overview/">淘秀网</a>爬虫端就是使用整合RabbitMQ这种解决方案来自动化控制与监控Scrapy爬虫。</p>
<h3 id="如何整合RabbitMQ与Scrapy爬虫？"><a href="#如何整合RabbitMQ与Scrapy爬虫？" class="headerlink" title="如何整合RabbitMQ与Scrapy爬虫？"></a>如何整合RabbitMQ与Scrapy爬虫？</h3><p>RabbitMQ在Python端的客户端实现是叫做<a href="https://pika.readthedocs.io/en/latest/intro.html">Pika</a>，这个RabbitMQ客户端提供了与别的RabbitMQ客户端大致相同的功能，如连接服务端，服务端连接管理，交换器管理，队列管理等等。我们将在我们的Scrapy中使用Pika来对RabbitMQ进行整合。</p>
<p>首先我们在<code>scrapy.cfg</code>同级目录下创建python运行文件<code>begin.py</code>，这个文件用于写我们的运行爬虫已经连接RabbitMQ相应的代码。</p>
<span id="more"></span>
<h4 id="连接RabbitMQ服务端部分"><a href="#连接RabbitMQ服务端部分" class="headerlink" title="连接RabbitMQ服务端部分"></a>连接RabbitMQ服务端部分</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建连接认证条件</span></span><br><span class="line">        pika_credentials = pika.credentials.PlainCredentials(rabbit_user, rabbit_pass)</span><br><span class="line">        <span class="comment"># 创建一个Blocking的连接</span></span><br><span class="line">        connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">            rabbit_host, port=rabbit_port, credentials=pika_credentials, connection_attempts=<span class="number">10</span>, socket_timeout=<span class="number">20</span>,</span><br><span class="line">            heartbeat=<span class="number">360</span>))</span><br><span class="line">        channel = connection.channel()</span><br><span class="line">        <span class="comment"># 声明交换器，这里应该和你消息生产者端保持一致设置</span></span><br><span class="line">        channel.exchange_declare(exchange=rabbit_exchange, exchange_type=<span class="string">&#x27;topic&#x27;</span>, durable=<span class="literal">True</span>, auto_delete=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 声明队列，这里应该和你消息生产者端保持一致设置</span></span><br><span class="line">        channel.queue_declare(queue=rabbit_queue, durable=<span class="literal">True</span>, exclusive=<span class="literal">False</span>, auto_delete=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 绑定操作</span></span><br><span class="line">        channel.queue_bind(exchange=rabbit_exchange,</span><br><span class="line">                           queue=rabbit_queue,</span><br><span class="line">                           routing_key=rabbit_queue)</span><br><span class="line">        <span class="comment"># 类似权重，按能力分发，如果有一个消息，就不在给你发，控制单个蜘蛛消费数量</span></span><br><span class="line">        channel.basic_qos(prefetch_count=<span class="number">1</span>)  </span><br><span class="line">        channel.basic_consume(  <span class="comment"># 消费消息</span></span><br><span class="line">            callback,           <span class="comment"># 如果收到消息，就调用Callback</span></span><br><span class="line">                                <span class="comment"># 这里的Callback函数我们下文将会提到，其实就是运行我们的Scrapy蜘蛛语句</span></span><br><span class="line">            queue=rabbit_queue, <span class="comment"># 队列</span></span><br><span class="line">            <span class="comment"># no_ack=True       # 一般不写，处理完接收处理结果。宕机则发给其他消费者</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">        <span class="comment"># 开启RabbitMQ接收模式，这代码会阻塞运行，直到爬虫完成任务，才会继续</span></span><br><span class="line">        channel.start_consuming()</span><br><span class="line">    <span class="comment"># 对一些连接错误进行处理，将继续执行循环，从而完成重连</span></span><br><span class="line">    <span class="keyword">except</span> pika.exceptions.ConnectionClosed:</span><br><span class="line">        <span class="comment"># Uncomment this to make the example not attempt recovery</span></span><br><span class="line">        <span class="comment"># from server-initiated connection closure, including</span></span><br><span class="line">        <span class="comment"># when the node is stopped cleanly</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># break</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># Do not recover on channel errors</span></span><br><span class="line">    <span class="keyword">except</span> pika.exceptions.AMQPChannelError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Caught a channel error: &#123;&#125;, stopping...&quot;</span>.<span class="built_in">format</span>(err))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Recover on all other connection errors</span></span><br><span class="line">    <span class="keyword">except</span> pika.exceptions.AMQPConnectionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection was closed, retrying...&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>首先我们需要创建一个连接至RabbitMQ服务端的连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 创建一个Blocking的连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    rabbit_host, port=rabbit_port, credentials=pika_credentials, connection_attempts=<span class="number">10</span>, socket_timeout=<span class="number">20</span>,</span><br><span class="line">    heartbeat=<span class="number">360</span>))</span><br></pre></td></tr></table></figure>
<p>这句话支持一些RabbitMQ队列连接相关的参数设置，如验证信息，重试次数，超时时间，心跳间隔等等，具体参数列表可以查看官方文档<a href="https://pika.readthedocs.io/en/0.12.0/modules/parameters.html">关于参数的介绍</a>。</p>
<p>然后就是相关的队列设置，交换器设置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel = connection.channel()</span><br><span class="line">        <span class="comment"># 声明交换器，这里应该和你消息生产者端保持一致设置</span></span><br><span class="line">        channel.exchange_declare(exchange=rabbit_exchange, exchange_type=<span class="string">&#x27;topic&#x27;</span>, durable=<span class="literal">True</span>, auto_delete=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 声明队列，这里应该和你消息生产者端保持一致设置</span></span><br><span class="line">        channel.queue_declare(queue=rabbit_queue, durable=<span class="literal">True</span>, exclusive=<span class="literal">False</span>, auto_delete=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 绑定操作</span></span><br><span class="line">        channel.queue_bind(exchange=rabbit_exchange,</span><br><span class="line">                           queue=rabbit_queue,</span><br><span class="line">                           routing_key=rabbit_queue)</span><br><span class="line">        <span class="comment"># 类似权重，按能力分发，如果有一个消息，就不在给你发，控制单个蜘蛛消费数量</span></span><br><span class="line">        channel.basic_qos(prefetch_count=<span class="number">1</span>)  </span><br><span class="line">        channel.basic_consume(  <span class="comment"># 消费消息</span></span><br><span class="line">            callback,           <span class="comment"># 如果收到消息，就调用Callback</span></span><br><span class="line">                                <span class="comment"># 这里的Callback函数我们下文将会提到，其实就是运行我们的Scrapy蜘蛛语句</span></span><br><span class="line">            queue=rabbit_queue, <span class="comment"># 队列</span></span><br><span class="line">            <span class="comment"># no_ack=True       # 一般不写，处理完接收处理结果。宕机则发给其他消费者</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>使用下面这句话开启我们的RabbitMQ Python客户端，之后便可以连接上RabbitMQ服务端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启RabbitMQ接收模式，这代码会阻塞运行，直到爬虫完成任务，才会继续</span></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>最后我们使用<code>while</code>语句，处理可能出现的连接异常，使我们的代码可以在出现连接异常的情况下，自动重新连接运行。</p>
<h4 id="如何运行我们的Scrapy爬虫？"><a href="#如何运行我们的Scrapy爬虫？" class="headerlink" title="如何运行我们的Scrapy爬虫？"></a>如何运行我们的Scrapy爬虫？</h4><p>上文我们提到了当有消息分配给我们这个客户端的时候，代码会触发<code>callback函数</code>，很明显我们需要在<code>callback函数</code>中运行我们的Scrapy蜘蛛。接下来我们看看如何写这个<code>callback函数</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">from</span> crochet <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> scrapy.crawler <span class="keyword">import</span> CrawlerRunner</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.log <span class="keyword">import</span> configure_logging</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"><span class="comment"># 导入我们自己写的蜘蛛</span></span><br><span class="line"><span class="keyword">from</span> mars.spiders.myspider <span class="keyword">import</span> Spider</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line"></span><br><span class="line">settings = get_project_settings()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">used_channel, basic_deliver, properties, body</span>):</span><br><span class="line">    <span class="comment"># 获取到消息队列中的消息</span></span><br><span class="line">    decodebody = <span class="built_in">bytes</span>.decode(body)</span><br><span class="line">    logger.info(<span class="string">&quot; [x] Received %r&quot;</span> % decodebody)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        run_spider(key_word_arg=decodebody, used_channel=used_channel, delivery_tag=basic_deliver.delivery_tag)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">        logger.error(error)</span><br><span class="line">        <span class="comment"># 告诉生产者，消息未处理完成</span></span><br><span class="line">        channel.basic_reject(delivery_tag=basic_deliver.delivery_tag)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_spider</span>(<span class="params">key_word_arg, used_channel, delivery_tag</span>):</span><br><span class="line">    <span class="comment"># 使用CrawlerRunner运行蜘蛛</span></span><br><span class="line">    crawler = CrawlerRunner(settings)</span><br><span class="line">    <span class="comment"># 运行我们自己写的蜘蛛</span></span><br><span class="line">    crawler.crawl(Spider, key_word_arg=key_word_arg, channel=used_channel, delivery_tag=delivery_tag)</span><br></pre></td></tr></table></figure>
<p>官方文档中，运行Scrapy蜘蛛有两种方式，一种叫做<code>CrawlerProcess</code>，另外一种叫做<code>CrawlerRunner</code>，我们在这里无法使用<code>CrawlerProcess</code>运行蜘蛛，因为当蜘蛛完成一次爬行后，接收到第二个消息，准备再次爬行时，使用<code>CrawlerProcess</code>会报<code>twisted.internet.error.ReactorNotRestartable</code>错误，导致蜘蛛无法再运行。而使用<code>CrawlerRunner</code>将完美解决这个问题。</p>
<p>这个解决方案中关键的一步是使用<code>from crochet import setup</code>导入<code>setup()</code>，并将<code>setup()</code>置顶放置。解决方法详细内容参见<a href="https://stackoverflow.com/a/47581199/3189161">这里</a>。</p>
<p>最后运行蜘蛛，这里可以通过传参，传入一些自定义参数，像下面我代码中<code>channel=used_channel</code>，传入channel的目的是为了让我们有能力在蜘蛛中向RabbitMQ客户端实现消息确认。这些都不是强制的，关键看你自己的蜘蛛如何实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行我们自己写的蜘蛛</span></span><br><span class="line">crawler.crawl(Spider, key_word_arg=key_word_arg, channel=used_channel, delivery_tag=delivery_tag)</span><br></pre></td></tr></table></figure>

<h4 id="如何运行整个文件"><a href="#如何运行整个文件" class="headerlink" title="如何运行整个文件"></a>如何运行整个文件</h4><p>我们只需要像执行普通python文件一样执行这个<code>begin.py</code>文件即可，程序会自动连接至RabbitMQ服务端，自动获取消息，自动执行，当消费完一个消息后，自动获取下个消息进行消费。</p>
<h3 id="完整版代码"><a href="#完整版代码" class="headerlink" title="完整版代码"></a>完整版代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">from</span> crochet <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> scrapy.crawler <span class="keyword">import</span> CrawlerRunner</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.log <span class="keyword">import</span> configure_logging</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"><span class="comment"># 导入我们自己写的蜘蛛</span></span><br><span class="line"><span class="keyword">from</span> mars.spiders.myspider <span class="keyword">import</span> Spider</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line"><span class="comment"># 获取setting.py文件</span></span><br><span class="line">settings = get_project_settings()</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;begin.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">configure_logging(settings)</span><br><span class="line">logger.info(<span class="string">&#x27; [*] Starting begin.py...&#x27;</span>)</span><br><span class="line">rabbit_host = settings.get(<span class="string">&quot;RABBITMQ_HOST&quot;</span>)</span><br><span class="line">rabbit_port = settings.get(<span class="string">&quot;RABBITMQ_PORT&quot;</span>)</span><br><span class="line">rabbit_user = settings.get(<span class="string">&quot;RABBITMQ_USERNAME&quot;</span>)</span><br><span class="line">rabbit_pass = settings.get(<span class="string">&quot;RABBITMQ_PASSWORD&quot;</span>)</span><br><span class="line">rabbit_exchange = settings.get(<span class="string">&quot;MY_EXCHANGE&quot;</span>)</span><br><span class="line">rabbit_queue = settings.get(<span class="string">&quot;MY_SCRAPY_QUEUE&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">used_channel, basic_deliver, properties, body</span>):</span><br><span class="line">    <span class="comment"># 获取到消息队列中的消息</span></span><br><span class="line">    decodebody = <span class="built_in">bytes</span>.decode(body)</span><br><span class="line">    logger.info(<span class="string">&quot; [x] Received %r&quot;</span> % decodebody)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        run_spider(key_word_arg=decodebody, used_channel=used_channel, delivery_tag=basic_deliver.delivery_tag)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">        logger.error(error)</span><br><span class="line">        <span class="comment"># 告诉生产者，消息未处理完成</span></span><br><span class="line">        channel.basic_reject(delivery_tag=basic_deliver.delivery_tag)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_spider</span>(<span class="params">key_word_arg, used_channel, delivery_tag</span>):</span><br><span class="line">    <span class="comment"># 使用CrawlerRunner运行蜘蛛</span></span><br><span class="line">    crawler = CrawlerRunner(settings)</span><br><span class="line">    <span class="comment"># 运行我们自己写的蜘蛛</span></span><br><span class="line">    crawler.crawl(Spider, key_word_arg=key_word_arg, channel=used_channel, delivery_tag=delivery_tag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建连接认证条件</span></span><br><span class="line">        pika_credentials = pika.credentials.PlainCredentials(rabbit_user, rabbit_pass)</span><br><span class="line">        <span class="comment"># 创建一个Blocking的连接</span></span><br><span class="line">        connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">            rabbit_host, port=rabbit_port, credentials=pika_credentials, connection_attempts=<span class="number">10</span>, socket_timeout=<span class="number">20</span>,</span><br><span class="line">            heartbeat=<span class="number">360</span>))</span><br><span class="line">        channel = connection.channel()</span><br><span class="line">        <span class="comment"># 声明交换器，这里应该和你消息生产者端保持一致设置</span></span><br><span class="line">        channel.exchange_declare(exchange=rabbit_exchange, exchange_type=<span class="string">&#x27;topic&#x27;</span>, durable=<span class="literal">True</span>, auto_delete=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 声明队列，这里应该和你消息生产者端保持一致设置</span></span><br><span class="line">        channel.queue_declare(queue=rabbit_queue, durable=<span class="literal">True</span>, exclusive=<span class="literal">False</span>, auto_delete=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 绑定操作</span></span><br><span class="line">        channel.queue_bind(exchange=rabbit_exchange,</span><br><span class="line">                           queue=rabbit_queue,</span><br><span class="line">                           routing_key=rabbit_queue)</span><br><span class="line">        <span class="comment"># 类似权重，按能力分发，如果有一个消息，就不在给你发，控制单个蜘蛛消费数量</span></span><br><span class="line">        channel.basic_qos(prefetch_count=<span class="number">1</span>)  </span><br><span class="line">        channel.basic_consume(  <span class="comment"># 消费消息</span></span><br><span class="line">            callback,           <span class="comment"># 如果收到消息，就调用Callback</span></span><br><span class="line">                                <span class="comment"># 这里的Callback函数我们下文将会提到，其实就是运行我们的Scrapy蜘蛛语句</span></span><br><span class="line">            queue=rabbit_queue, <span class="comment"># 队列</span></span><br><span class="line">            <span class="comment"># no_ack=True       # 一般不写，处理完接收处理结果。宕机则发给其他消费者</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">        <span class="comment"># 开启RabbitMQ接收模式，这代码会阻塞运行，直到爬虫完成任务，才会继续</span></span><br><span class="line">        channel.start_consuming()</span><br><span class="line">    <span class="comment"># 对一些连接错误进行处理，将继续执行循环，从而完成重连</span></span><br><span class="line">    <span class="keyword">except</span> pika.exceptions.ConnectionClosed:</span><br><span class="line">        <span class="comment"># Uncomment this to make the example not attempt recovery</span></span><br><span class="line">        <span class="comment"># from server-initiated connection closure, including</span></span><br><span class="line">        <span class="comment"># when the node is stopped cleanly</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># break</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># Do not recover on channel errors</span></span><br><span class="line">    <span class="keyword">except</span> pika.exceptions.AMQPChannelError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Caught a channel error: &#123;&#125;, stopping...&quot;</span>.<span class="built_in">format</span>(err))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Recover on all other connection errors</span></span><br><span class="line">    <span class="keyword">except</span> pika.exceptions.AMQPConnectionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection was closed, retrying...&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p>完</p>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li><li><a href="https://blog.ours1984.top/posts/regex/">正则表达式的使用</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>互联网技术</tag>
        <tag>python</tag>
        <tag>淘秀网</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Switch硬件破解经验分享 - 破解芯片固件升级篇</title>
    <url>/posts/53cdbb65/</url>
    <content><![CDATA[<blockquote>
<p>本文仅为本人对破解的理解以及相关实践的总结，仅供参考。</p>
</blockquote>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li><p><strong>关于芯片：</strong> 这里指的是hwfly芯片，即所谓的国产芯片，该芯片目前已经出了多代，第四代芯片是可以对芯片的固件进行更新升级或者改刷别的开源固件的。</p>
<p>  <strong>目前可刷的固件有：</strong></p>
<ul>
<li><a href="https://github.com/hwfly-nx/firmware">hwfly-nx</a></li>
<li><a href="https://www.chipnx.com/">hwfly官方固件</a></li>
</ul>
</li>
</ul>
<p> 这里主要介绍续航版国产芯片升级hwfly-nx固件，其余版本芯片升级或升级别的固件请酌情参考。</p>
<span id="more"></span>
<ul>
<li><p><strong>如何判断当前芯片是否为国产四代芯片:</strong></p>
<p>芯片左上角为MV1-7以上,即为四代或更新的芯片, 如下图</p>
<p> <img src="/img/switch/Flashable-Core-SWD.jpg" alt="四代"></p>
</li>
</ul>
<h2 id="hwfly-nx固件介绍"><a href="#hwfly-nx固件介绍" class="headerlink" title="hwfly-nx固件介绍"></a>hwfly-nx固件介绍</h2><p>hwfly-nx（<a href="https://github.com/hwfly-nx/firmware/releases/latest">最新固件下载地址</a>）是一个完全开源的芯片固件，用于链式引导您自己的playload，其支持SX Core &#x2F; Lite&#x2F; hwfly等芯片</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>将兼容的有效playload（如 <a href="https://github.com/CTCaer/hekate/releases">hekate</a> ），重命名payload.bin，并放在您的 sd 卡根目录中。</li>
<li>第一次开启时，芯片将进行初始脉冲训练（最多 5 分钟），完成后破解芯片将准备就绪，后续就可以更快速的启动。</li>
<li>在启动期间按住 VOL+ 可防止破解芯片进入睡眠状态（一般破解完成后，破解芯片就会关闭，LED灯会熄灭）。这操作完成后可以允许破解芯片与<a href="https://github.com/hwfly-nx/hwfly-toolbox">hwfly-toolbox</a>交互以进行额外的对破解芯片的 操作和诊断。</li>
<li>启动switch后，当芯片脉冲破解成功但由于 sd 卡问题阻止加载 payload.bin 时，屏幕上会提供诊断。在这时， 可以通过同时按下 VOL+ 和 VOL- 来启动OFW。</li>
<li>在开机期间按住 VOL+ 和 VOL- 直到脉冲完成（绿灯亮起），会绕过任何有效的playload 并启动到 OFW。</li>
</ul>
<h3 id="LED诊断"><a href="#LED诊断" class="headerlink" title="LED诊断"></a>LED诊断</h3><p>  安装完成后的第一次启动，固件将自动进行脉冲破解训练。这时候主板上的LED灯呈黄色闪烁状态，最多可能需要 5 分钟。当完成第一次脉冲破解训练后，后续引导会快得多。有关可能的 LED 模式的完整概述，请参阅下图，这可能有助于对芯片安装完成后但不工作的情况下进行诊断。</p>
<p><img src="/img/switch/switch-modchip-led-pattern.gif" alt="诊断"></p>
<h3 id="如何更新破解芯片"><a href="#如何更新破解芯片" class="headerlink" title="如何更新破解芯片"></a>如何更新破解芯片</h3><p>  可以使用以下 3 种方法之一进行更新破解芯片：</p>
<p><strong>方法 a) - 使用 USB 引导加载程序（首选）</strong></p>
<ol>
<li>完全关闭你的switch主机。</li>
<li>在<strong>芯片上</strong>插入 USB 电缆。<strong>注意不要插入错误！！！ 不要插反！如果插反这会完全破坏芯片上的 USB 功能。正确插法如下图所示，注意up朝向!</strong><br><img src="/img/switch/Hwfly-for-switch-lite-oled-chip-ic-cable-black-board-payment-sx-cx.png_320x320.jpg" alt="正确插法"></li>
<li>运行<a href="https://github.com/hwfly-nx/firmware/releases/latest">最新固件下载地址</a>中的flash.bat。这会更新引导加载程序（bootloader）和破解固件（firmware），运行过完成后LED灯呈蓝色闪烁状态。<strong>如果刷固件时PC上出现错误，需要重新拔出USB，换个USB口子再重新执行刷固件程序，否则将会清除当前芯片上的固件。</strong></li>
<li>拔下 USB 电缆。</li>
<li>重新打开你的switch主机。</li>
</ol>
<p><strong>方法 b) - 使用 hwfly-toolbox 进行更新操作，该方法不需要打开设备后盖，但不能刷入引导程序（bootloader）。此时引导加载程序（bootloader）中的 LED 状态可能与上面LED状态图不一致。</strong></p>
<ol>
<li>从此获取<a href="https://github.com/hwfly-nx/hwfly-toolbox/releases">hwfly-toolbox</a>刷固件工具</li>
<li>将 hwfly_toolbox.bin 插入 sd卡的&#x2F;bootloader&#x2F;payloads&#x2F; 中。</li>
<li>切换引导到 hekate，选择playload然后运行 hwfly_toolbox.bin。</li>
<li>从hwfly_toolbox的菜单中更新SD loader。</li>
<li>从菜单关闭switch主机。</li>
<li>取出sd卡，将 firmware.bin和sdloader.enc 放到您的sd卡根目录。<strong>不要提早放</strong>。如果之前刷过测试版本的固件，需要创建一个名为.force_update的空文件到sd卡根目录。</li>
<li>将sd卡放回switch主机，按住VOL+按钮开机（如果进入hekate后绿灯一直亮，说明操作成功。</li>
<li>再次从 hekate 运行 hwfly_toolbox。</li>
<li>从菜单更新固件（firmware）。</li>
<li>重新启动switch并完成更新。</li>
</ol>
<p><strong>方法c) - 外部编程器应用j-link、st-link、gd-link）</strong> </p>
<ol>
<li>参见<a href="https://www.sthetix.info/flashing-updating-unbricking-the-chip/">刷固件方法地址</a>。</li>
<li>提供的bootloader.bin应该在0x080000000处被刷入。提供的payload.bin应在0x08003000处被刷入。</li>
</ol>
<p><strong>注意</strong>：上面的三个方法没有一个可将无法更新固件的4代以前的芯片变成可更新固件的芯片。（不可更新固件的芯片在主板上使用一个 BGA FPGA类型控制芯片，而可更新固件的芯片主板上使用的是QFN FPGA类型控制芯片，硬件上是不通的）。</p>
<p><strong>安装完成后：</strong><br>使用以上方法升级完后，开机如果显示如下画面，则说明刷成功<br><img src="/img/switch/maxresdefault.jpg" alt="成功"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="无法关机Bug和解决办法"><a href="#无法关机Bug和解决办法" class="headerlink" title="无法关机Bug和解决办法"></a>无法关机Bug和解决办法</h3><p>国产芯片刷完最新固件（0.7.0）后目前主要 Bug 是在系统关机上，mariko 机型特别明显。简单说就是你选择关机之后，机器自动开机，芯片开始工作。</p>
<p>这个不管真实（正版）系统、真实（破解）系统，还是虚拟系统下，都一 样。而且不管你是通过按住电源键选择“关闭电源”关机，还是 goldleaf 里面 按 ZL&#x2F;ZR 后点击 shutdown 关机，也都一样。</p>
<p>假如在 bootloader&#x2F;hekate_ipl.ini 中配置 autoboot&#x3D;0，则自动开机会停 留在 hekate 的 RCM 菜单里，这就带来一个严重问题，首先机器会非常耗电且 机器热量也会立刻增加，假如长时间放在包里，其实不利于机器散热，容易造成硬件隐患。</p>
<p><strong>解决正常关机的办法如下：</strong></p>
<p>1、<strong>正确操作：</strong> 先重启或者等自动开机到 hekate 下，选择 power off 关机就不会再自动开机了。</p>
<p>2、<strong>实用操作：</strong> 索性不关机，采取息屏待机状态，那么耗电其实也不大，一 晚上最多 3-5%。类似当初爆浆机使用 autorcm 免短接时候。</p>
<p>3、<strong>实用操作：</strong> 设置 hekate 的 autoboot&#x3D;虚拟系统或真实系统，这样就 算关机后自动重启，也会进入系统自动待机，记得系统设置里开启锁屏。</p>
<p>4、<strong>建议操作：</strong> 启动后进入 hekate 设置页面，把 Auto HOS Power Off 选项设置成 ON，保存，后面正常关机后，过大约15秒还是会自动开机但进入 hekate 后会自动关机。</p>
<p>除了关机后自动开机这个主要 bug 之外，别的bug暂时没有遇到。</p>
<p>如果出现 bug，建议的解决方式也只需要你按住电源键 15 秒以上强制关机后重新开机就能解决。</p>
<hr>
<blockquote>
<p>引用</p>
</blockquote>
<ol>
<li><a href="https://github.com/hwfly-nx/firmware">hwfly-nx固件Github地址</a></li>
<li><a href="https://www.marsshen.com/2022/05/29/switch-hack-terminology/">Switch硬件破解经验分享 - 术语篇</a></li>
<li><a href="http://www.265xh.com/nszhinan/4246.html">简析国产三种NS芯片区别及Spacecraft固件Bug</a></li>
</ol>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/f96d7ec4/">Switch硬件破解经验分享 - 术语篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>switch硬破教程</tag>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title>Switch硬件破解经验分享 - 术语篇</title>
    <url>/posts/f96d7ec4/</url>
    <content><![CDATA[<h3 id="RCM"><a href="#RCM" class="headerlink" title="RCM"></a><strong>RCM</strong></h3><p>  RCM 是 ReCovery Mode 的缩写, 即恢复模式.</p>
<h3 id="Horizon-OS-HOS"><a href="#Horizon-OS-HOS" class="headerlink" title="Horizon OS (HOS)"></a><strong>Horizon OS (HOS)</strong></h3><p>  Horizon 是 Nintendo Switch 操作系统的名称.</p>
<h3 id="OFW"><a href="#OFW" class="headerlink" title="OFW"></a><strong>OFW</strong></h3><p>  OFW 是 Original Firmware的缩写, 即官方原版胸固件.</p>
<p>  这指的是你设备中没有被修改的原始系统固件.</p>
<span id="more"></span>
<h3 id="CFW"><a href="#CFW" class="headerlink" title="CFW"></a><strong>CFW</strong></h3><p>  CFW 是 Custom Firmware 的缩写, 即自制系统固件.</p>
<p>  这指的是被修改的自制系统固件, 第三方自制程序(homebrew)被允许在此类系统固件上运行.</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><strong>Homebrew</strong></h3><p>  一般用于描述开发人员为锁定的(非开放的)系统创建的非官方软件.</p>
<p>  对于 Switch 来说, 此类软件可以包括存档管理器, 模拟器或破解游戏.</p>
<h3 id="Atmosphere"><a href="#Atmosphere" class="headerlink" title="Atmosphere"></a><strong>Atmosphere</strong></h3><p>  大气层自制固件(Atmosphere), 一个免费开源的第三方自制固件(CFW), <a href="https://github.com/Atmosphere-NX/Atmosphere">Github地址</a>.</p>
<h3 id="SXOS"><a href="#SXOS" class="headerlink" title="SXOS"></a><strong>SXOS</strong></h3><p>  由 Team Xecuter 创建的付费并封闭源代码的自制固件(CFW), 由于TX团队已经由于破解盈利被抓捕, 所以相关固件也已经不再更新.</p>
<p>  不适用于 11.0.0 以上的固件.</p>
<h3 id="NAND"><a href="#NAND" class="headerlink" title="NAND"></a><strong>NAND</strong></h3><p>  NAND是switch设备中内置的存储(不要与 SD 卡存储混淆).</p>
<p>  Switch 一般拥有 32GB 内置存储(25.9GB 可用存储, 其余被系统占用).</p>
<h3 id="SysNAND"><a href="#SysNAND" class="headerlink" title="SysNAND"></a><strong>SysNAND</strong></h3><p>  SysNAND 是 “System NAND” 的缩写, 即设备机身内置存储.</p>
<p>  SysNAND中的内容是存储在机身内置存储中的内容(不要与OFW混淆).</p>
<p>  它包含从操作系统本身到游戏、屏幕截图、视频和保存文件的所有内容.</p>
<p>  无论是被破解或未被破解的设备都有一个SysNAND.</p>
<p>  我们常说的正版系统一般就存储在此.</p>
<h3 id="EmuNAND"><a href="#EmuNAND" class="headerlink" title="EmuNAND"></a><strong>EmuNAND</strong></h3><p>  EmuNAND 是 “Emulated NAND”的缩写, 即虚拟内置存储.</p>
<p>  EmuNAND 是 SysNAND的副本，它存储在 SD 卡上，而不是在设备内部存储器上.</p>
<p>  可以把它想象成在你的 SD 卡上 有一个独立的额外的Nintendo Switch. </p>
<p>  一般在 EmuNAND 中的任何更改或操作都不会影响您的 SysNAND，因为它是一个独立的副本。</p>
<p>  我们常说的虚拟系统一般就存储在此.</p>
<div class="admonition warning"><p class="admonition-title">注意
</p><p><strong>使用 EmuNAND 并不能确保你不会被Ban。 单击此处了解有关如何避免被Ban的更多信息。</strong></p>
</div>

<h3 id="Signature-Patches"><a href="#Signature-Patches" class="headerlink" title="Signature Patches"></a><strong>Signature Patches</strong></h3><p>  Signature Patches(签名补丁)或 SigPatches 允许您的设备绕过 Horizon 对已安装程序执行的签名检查.</p>
<h3 id="Hekate"><a href="#Hekate" class="headerlink" title="Hekate"></a><strong>Hekate</strong></h3><p>  一个免费开源的自定义引导加载程序(bootloader)，可让您绕过熔断数检查, 并且其拥有许多有用的工具. <a href="https://github.com/CTCaer/hekate">Github地址</a>.</p>
<p>  可用于启动 OFW、CFW、Android、Linux 和任何其他有效payload.</p>
<h3 id="Fusee"><a href="#Fusee" class="headerlink" title="Fusee"></a><strong>Fusee</strong></h3><p>  一个迷你自定义引导加载程序(bootloader), 仅用于引导大气层自制固件(Atmosphere).<br>  Hekate 和 Fusee 之间的区别在于, Hekate 需要一个自定义配置文件来告诉Atmosphere它应该使用哪些 KIP、补丁和其他设置, 而Fusee会自动启动它们.</p>
<h3 id="NSP"><a href="#NSP" class="headerlink" title="NSP"></a><strong>NSP</strong></h3><p>  NSP 是 Nintendo Submission Package 的缩写.</p>
<p>  NSP是已安装title的转储安装程序包或可以安装的自制程序包. eShop中的数字版一般都为此格式.</p>
<h3 id="XCI"><a href="#XCI" class="headerlink" title="XCI"></a><strong>XCI</strong></h3><p>  XCI 是 NX Card Image 的缩写.</p>
<p>  XCI 是 switch 卡带dump文件镜像. switch 卡带中文件一般为此格式.</p>
<h3 id="NSZ"><a href="#NSZ" class="headerlink" title="NSZ"></a><strong>NSZ</strong></h3><p>  一种压缩后的 NSP 文件.</p>
<h3 id="XCZ"><a href="#XCZ" class="headerlink" title="XCZ"></a><strong>XCZ</strong></h3><p>  一种压缩后的 XCI 文件.</p>
<h3 id="NRO"><a href="#NRO" class="headerlink" title="NRO"></a><strong>NRO</strong></h3><p>  homebrew 应用程序使用的扩展.</p>
<h3 id="sx-core-x2F-lite"><a href="#sx-core-x2F-lite" class="headerlink" title="sx core&#x2F;lite"></a><strong>sx core&#x2F;lite</strong></h3><p>  TX小组研发的硬件破解芯片，目前小组成员被抓，相关产品停产，固件不再更新。</p>
<h3 id="HWFLY"><a href="#HWFLY" class="headerlink" title="HWFLY"></a><strong>HWFLY</strong></h3><p>  国产芯片名称, 截止目前最新版本为第四代芯片。<a href="https://www.chipnx.com/">官网</a></p>
<p>  其原理为开机触发脉冲漏洞破解 switch 主机，只要破解后芯片就不再工作, 后续工作交给 tf 卡上的自定义引导加载程序(bootloader), 只有关机后下次开机才需要重新触发。</p>
<h3 id="Spacecraft-NX"><a href="#Spacecraft-NX" class="headerlink" title="Spacecraft-NX"></a><strong>Spacecraft-NX</strong></h3><p>  开源的破解芯片固件，<a href="https://github.com/Spacecraft-NX/firmware">Github地址</a></p>
<p>  switch oled之后的版本请务必刷0.2以后的固件版本。</p>
<h3 id="hwfly-nx"><a href="#hwfly-nx" class="headerlink" title="hwfly-nx"></a><strong>hwfly-nx</strong></h3><p>  开源的破解芯片固件， 由于Spacecraft-NX更新缓慢，一些开发者开发基于Spacecraft-NX创建了hwfly-nx固件。 <a href="https://github.com/hwfly-nx">Github地址</a></p>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>switch硬破教程</tag>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title>Switch硬件破解经验分享 - 破解焊接篇</title>
    <url>/posts/464772cb/</url>
    <content><![CDATA[<blockquote>
<p>本文仅为本人对破解的理解以及相关实践的总结，仅供参考。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天自己动手焊接了switch的破解芯片，完成了对续航版switch硬件破解，在此分享下自己对硬件破解芯片焊接的一些经验。<br>这篇文章针对的是续航版，OLED和lite焊接难度较大，不建议自己焊接了；而普通版可以软破，也不建议焊接。</p>
<p>在开始破解之前，想说明几点：</p>
<ol>
<li>首先要说的是，你要对自己有信心，我自己也是零焊接经验，通过几个视频，简单的练习，完成芯片焊接。只要你心态没有问题，手不抖，完全可以自己完成芯片焊接。</li>
<li>其次是不要对自己过分自信，当你拆开后盖的一瞬间（也许你连后盖都拆不开），你会发现你要焊接的点位上的电容只有芝麻大小。所以在焊接工作前，做好充分的准备工作，放平心态，可以让你的焊接破解成功率提升不少。</li>
<li>如果看完这篇文章后还是对自己没有信心，那我劝你放弃不要继续了，大概率可能会失败。<span id="more"></span></li>
</ol>
<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>工欲善其事必先利其器，想要做好这个手工活必须得有一些趁手的工具。以下是我为这次破解准备的一些工具。</p>
<ul>
<li><p><strong>电洛铁 + 锡丝</strong><br>  必需品。这个不需多说，没有电洛铁无法焊接芯片，这里我选择可恒温电洛铁，电洛铁头可以选择尖头，对新手相对友好。同时建议在网上看一些电洛铁操作入门教学，了解下基础操作，一般学习时长也就半小时左右。成本的话大概50左右，这个价位完全可以胜任本次操作，也不需要买太好。</p>
</li>
<li><p><strong>助焊剂</strong><br>  必需品。为了提高成功率，还是需要使用助焊剂的，助焊剂能使你的焊点更容易上锡，焊点更饱满，简单的说可以使焊接更简单。推荐使用半固态的助焊剂，我买的那种是有个针头可以把助焊剂推出来推到焊点上的那种，操作的时候可以推一点助焊剂到焊点上再焊接。成本的话大约几十块钱。</p>
</li>
<li><p><strong>绝缘隔热胶带</strong><br>  必需品。同样也是必须品，对于新手焊接来说，固定排线和保护别的原件是很重要的事情。这两件事情，绝缘隔热胶带能办到。这种胶带一般长的黄色透明，你可以在很多视频里看到他，一般可以隔绝300℃左右的高温，保护别的元器件不受干扰。成本大约几块钱。</p>
</li>
<li><p><strong>洗板水或无水酒精</strong><br>  建议。用于清理主板上的硅脂残留物以及焊接留下的助焊剂残渣，个人建议还是入手一瓶，成本大约十块左右。</p>
</li>
<li><p><strong>除锡带</strong><br>  可选。新手焊接难免会上锡上多或上少，上多的话可以用除锡带将多余的锡吸走。成本大约几块钱。</p>
</li>
<li><p><strong>螺丝刀 + 备用螺丝</strong><br>  建议。拆机需要用到1.5的十字螺丝刀以及1.5的Y字螺丝刀，需要提前准备好，如果螺丝坏了或者不小心掉了，可以使用备用螺丝顶上，总成本大约十来块钱。</p>
</li>
<li><p><strong>手机&#x2F;放大镜&#x2F;焊接显微镜</strong><br>  可选。CPU上的电容非常的小，建议搞个放大镜，如果有条件的可以上个PCB板焊接用的显微镜。我自己的话没这个条件，所以使用的是手机照相机。找个手机支架，然后开摄像模式，对准焊接的点位进行放大，一般来说就看到清楚了，这样相对肉眼容易焊接一点。</p>
</li>
</ul>
<h2 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h2><p>准备完工具之后，还需要一块破解芯片，它是焊接的主角。</p>
<p>我用的是hwfly国产第四代芯片，即所谓的国产山寨芯片。它是目前相对较容易拿到的芯片，同时也支持刷固件，可玩性较高。TX芯片没有接触过，现在市面上也较少，但焊接原理和国产芯片一样。</p>
<p>芯片主要由芯片主体，排线，以及USB插排组成。<br><img src="/img/switch/Hwfly-for-switch-lite-oled-chip-ic-cable-black-board-payment-sx-cx.png_320x320.jpg" alt="hwfly芯片"><br>排线的话由于我们是续航版，所以选择V2就行。V1是给普通版准备的排线。</p>
<h2 id="拆机"><a href="#拆机" class="headerlink" title="拆机"></a>拆机</h2><p>破解的第一步就是拆机，千万千万要有耐心，特别是第一次拆机，一定要用对工具，否则原装螺丝容易滑丝，滑丝后就比较麻烦。如果真的不小心滑丝了，也不要着急，千万别听信网上说用胶水，用了胶水后壳可就真的废了。滑丝后靠谱的解法就是刻一字，然后用一字螺丝拧下，别问我为什么知道，因为我滑丝了。</p>
<p>螺丝点位以下这张图描述的比较清楚，按这张图拧就行。<br><img src="/img/switch/c1.jpg" alt="拆机螺丝点位"></p>
<p>注意下后盖上面是有卡扣的，不要硬掰，抬起后盖下半部分，慢慢往下拉即可绕出卡扣。</p>
<p>后盖拆下后，后面就比较简单了，按顺序拆除即可。</p>
<p>正确的顺序是：后盖 -&gt; tf卡槽 -&gt; 金属屏蔽罩 -&gt; 散热铜管 -&gt; CPU屏蔽罩和 NAND 颗粒芯片，具体拆解方式可以参考下图。</p>
<p><strong>tf卡槽和金属屏蔽罩</strong><br><img src="/img/switch/c2.jpg" alt="TF卡槽和金属屏蔽罩"></p>
<p><strong>散热铜管</strong><br><img src="/img/switch/c3.jpg" alt="SOC散热铜管"></p>
<p><strong>CPU屏蔽罩</strong><br>SOC屏蔽罩拆解有点难度，一般拆完都比较容易变形，最好可以找个趁手的工具，将中间卡扣挑起，就比较容易拆。<br><img src="/img/switch/c4.jpg" alt="SOC屏蔽罩"></p>
<p>拆完后CPU裸露处理，我们要做的是用洗板水或者酒精将硅脂擦干净，特别是电容边上的硅脂，后面焊接要用到。<br><img src="/img/switch/c5.jpg" alt="清洁硅脂"></p>
<h2 id="焊接"><a href="#焊接" class="headerlink" title="焊接"></a>焊接</h2><p>焊接的方法主要就是下图，有一个重要的技巧，就是焊接前，一定要先在排线上上锡，然后再把上过锡的排线固定在CPU上，用之前准备的绝缘隔热胶带将要焊接的电容边上的电容都贴起来挡住，防止焊坏边上的原件。之后使用电洛铁接触排线上的焊点2-3秒，同时向电容方向轻轻的推即可。<br><img src="/img/switch/c6.jpg" alt="焊接焊点"></p>
<p>焊完之后应该是这样的：<br><img src="/img/switch/c7.jpg" alt="焊接效果"></p>
<p>这里有个焊接的视频讲的非常详细与到位，可以参考下：</p>
<iframe src="//player.bilibili.com/player.html?aid=969301681&bvid=BV1rp4y1v7zh&cid=225560839&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><a href="https://www.bilibili.com/video/BV1rp4y1v7zh">https://www.bilibili.com/video/BV1rp4y1v7zh</a></p>
<p>对于CPU上的电容非常的小看不清的问题。我自己使用的是手机的照相机，找个手机支架，然后开摄像模式，对准焊接的点位进行放大，一般来说就看到清楚了，这样相对肉眼容易焊接一点。</p>
<h2 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h2><p>接下来只要将Nand插在芯片，然后将CPU上的排线插上芯片，芯片插在之前查Nand的插座上就行。参考下图<br><img src="/img/switch/c8.jpg" alt="装机图"></p>
<p>开机测试下，第一次开机时间可能较长，一般来说LED应该是 黄（闪烁） -&gt; 紫（闪烁） -&gt; 绿(常亮)这个顺序，则表示安装没问题，否则则检查焊接是否到位，是否安装错误。</p>
<p>最后装上CPU屏蔽罩，安好之前拆下来的散热铜管，将芯片如下图安放即可，一般来说都会将芯片下的金属屏蔽罩剪掉一块，这样的话后盖不会凸起来。注意记得在CPU屏蔽罩上贴上绝缘隔热胶带，这样防止芯片短路。<br><img src="/img/switch/c9.jpg" alt="装机图"></p>
<p>安装完后，再用绝缘胶固定好芯片，按回后盖，就基本大功告成了。</p>
<hr>
<blockquote>
<p>引用</p>
</blockquote>
<ol>
<li><a href="https://baijiahao.baidu.com/s?id=1683417071721969170&wfr=spider&for=pc">关于Switch国行续航版TX芯片硬破的建议</a></li>
<li><a href="https://www.marsshen.com/2022/05/29/switch-hack-terminology/">Switch硬件破解经验分享 - 术语篇</a></li>
<li><a href="https://tieba.baidu.com/p/6747262057?red_tag=1250614440">switch贴吧-这个焊接教程挺详细的</a></li>
</ol>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/20e16ead/">Switch硬件破解经验分享 - 破解后折腾篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li><li><a href="https://www.marsshen.com/posts/f96d7ec4/">Switch硬件破解经验分享 - 术语篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>switch硬破教程</tag>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title>Switch硬件破解经验分享 - 破解后折腾篇</title>
    <url>/posts/20e16ead/</url>
    <content><![CDATA[<blockquote>
<p>本文仅为本人对破解的理解以及相关实践的总结，仅供参考。</p>
</blockquote>
<p>基于前面的文章，我们已经完成了硬破的所有工作，接下来的工作就是要让这台破解的机器真正跑起来了。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>安装完破解芯片后，每次重新开启switch主机，破解芯片将进行工作，将诱导主机载入我们自己的playload，通过这个自制playload，可以进一步引到主机运行自制固件。通常来说，目前主流的自制playload为Hekate，主流的自制固件为Atmosphere（也就是所谓的大气层固件）。所以我们现在要做的就是将整合了playload和大气层的文件整合包，塞到TF卡根目录。这个整合包可以自己做，也可以找网上别人做好的现成的整合包，下面简单介绍下如何制作整合包。</p>
<span id="more"></span>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><strong>检查是否破解成功：</strong><br>    如果机器正常破解，破解芯片正常安装，这时候按电源开机，应该提示 “NO SD”。</p>
<div class="admonition warning"><p class="admonition-title">注意
</p><p><strong>不同的芯片固件可能会显示不同，但是都会提示类似没有插入TF卡。</strong></p>
</div>

<p><strong>准备TF卡：</strong><br>    将TF卡分区表设置成 MBR 格式，GPT 格式 Switch 无法识别，通过格式化分区为 exfat。</p>
<h2 id="制作自己的整合包"><a href="#制作自己的整合包" class="headerlink" title="制作自己的整合包"></a>制作自己的整合包</h2><div class="admonition info"><p class="admonition-title">说明
</p><p><strong>这里介绍快捷制作自己整合包的方法，完全手动整合就不进一步介绍了，各位有兴趣可以自行研究。</strong></p>
</div>

<p>首先制作基础整合包。这里介绍两种基础整合包获取方式</p>
<p><strong>通过sdsetup网站获取自定义基础整合包：</strong><br>  这个网站专门用来定制自己的整合包，这里面的固件、组件等都是最新版本的更新非常快。</p>
<ol>
<li>进入(<a href="https://www.sdsetup.com/console?switch">sdsetup官网下载页</a>)。</li>
<li>选择Recommended Defaults或自己选择自己需要的组件后拉到最下面点击Download your ZIP下载。</li>
<li>解压下载下来的zip包，你会看到2个文件夹，sd和payloads，将sd卡里面的内容全部复制到TF卡根目录，然后将payloads中<code>hekate_ctcaer_x.x.x.bin</code>更名成<code>playload.bin</code>放入TF卡根目录。</li>
</ol>
<div class="admonition info"><p class="admonition-title">关于Lockpick_RCM.bin
</p><p><strong>payloads文件夹中<code>Lockpick_RCM.bin</code>可以用来备份主机key，有需要的同学可以自行搜索用法，这里就不赘述。</strong></p>
</div>

<p><strong>获取Neptune 团队的 DeepSea 基础整合包：</strong><br>  这是国外Neptune 团队的 DeepSea 整合包，维护很专业，通常更新也比较迅速。</p>
<ol>
<li>进入（<a href="https://github.com/Team-Neptune/DeepSea/releases">DeepSea整合包下载页面</a>)下载最新的发布版本，三个版本随意 (我用的全功能版)。</li>
<li>解压放入TF卡根目录，并将<code>hekate_ctcaer_x.x.x.bin</code>更名成<code>playload.bin</code>。</li>
</ol>
<p>完成上述两种方式任意一种后，将TF卡塞进switch主机，此刻正常情况下，开机后会进入 hekate 引导程序，如果没进入，请考虑是否整合包有问题。<br>如果你是国产芯片，关机后会变成重启，进入hekate后设置<code>options-&gt;Auto HOS Power Off</code>即可。</p>
<h3 id="备份-eMMC"><a href="#备份-eMMC" class="headerlink" title="备份 eMMC"></a>备份 eMMC</h3><p>Switch 内置的 eMMC 存储芯片有以下几个重要分区：BOOT0、BOOT1、GPP，GPP 内又包含 N 个子分区，比较重要的有两个 SYS (包含系统)、USER (包含用户数据)，USER 分区占用空间大约有 60G，因此一般不需要备份。</p>
<ol>
<li>进入hekate选择<code>Tools-&gt;Backup eMMC</code></li>
<li>备份 <code>eMMC BOOT0 &amp; BOOT1 + eMMC SYS</code>。</li>
<li>也可以完整备份，直接 <code>eMMC RAW GPP</code>，或者 <code>eMMC BOOT0 &amp; BOOT1</code> + <code>eMMC SYS+eMMC USER</code>，两者等价。</li>
<li>在hekate右下角选择<code>power off</code>关闭主机，拔出TF卡插入电脑，将TF卡中backup目录（备份文件）复制出保存在电脑上后，即可将TF卡中的backup目录删除。最后将TF卡插回主机，准备下一步操作。</li>
</ol>
<h3 id="制作虚拟系统"><a href="#制作虚拟系统" class="headerlink" title="制作虚拟系统"></a>制作虚拟系统</h3><p>制作系统前先进入真实系统 <code>Launch -&gt; Stock (SYSNAND)</code>，从内置存储启动系统且不加载破解，删除所有 WiFi，并开启飞行模式，重启。</p>
<ol>
<li>进入hekate，选择<code>emuMMC-&gt;Create emuMMC-&gt;SD File</code>，制作一个基于TF卡文件的虚拟系统，完成后我们的双系统就制作完成了。</li>
</ol>
<div class="admonition info"><p class="admonition-title">这里稍微说下基于TF卡文件与基于TF卡分区的区别。
</p><p><strong>基于SD卡分区的虚拟系统：</strong></p>
<ul>
<li>优点：
出错的可能性最小。</li>
<li>缺点：
创建新的虚拟系统需要你对 SD 卡进行分区，因此 SD 上的现有文件将被删除。
迁移到新的 SD 卡或备份虚拟系统要复杂得多。</li>
</ul>
<p><strong>基于 SD 文件的虚拟系统：</strong></p>
<ul>
<li>优点：
非常容易传输或备份。
创建新的虚拟系统更容易，并且不需要你对 SD 卡进行分区。</li>
<li>缺点：
你的虚拟系统设置损坏的可能性更高。
这适用于FAT32和exFAT用户。
无法通过系统设置在 SD 卡和虚拟系统之间传输游戏，这是一个没修复的bug。</li>
</ul>
</div>

<ol start="2">
<li>我们现在在Launch菜单中可以看到以下4个选项<ul>
<li><strong>Stock (SYSNAND)：</strong> 从机身内部的 eMMC 启动系统，不加载破解，也就是真实系统。</li>
<li><strong>CFW (SYSNAND)：</strong> 从机身内部的 eMMC 启动系统，加载破解，不建议选择这一项，非常容易被ban。</li>
<li><strong>CFW (EMUMMC)：</strong> 从 SD 卡的虚拟系统启动，加载破解，也就是虚拟系统，建议用此进入虚拟系统。</li>
<li><strong>Fusee：</strong> 使用大气层playload引导，从 SD 卡的虚拟系统启动，加载破解，也就是大气层引导的虚拟系统。</li>
</ul>
</li>
</ol>
<h3 id="处理虚拟系统"><a href="#处理虚拟系统" class="headerlink" title="处理虚拟系统"></a>处理虚拟系统</h3><div class="admonition info"><p class="admonition-title">准备下一步前
</p><p><strong>关机并拔出 TF 卡，将TF卡连接电脑。</strong></p>
</div>

    
<p><strong>删除虚拟系统序列号：</strong></p>
<ol>
<li>复制 <code>atmosphere/config_templates/exosphere.ini</code> 到 SD 卡根目录 <code>blank_prodinfo_emummc</code> 改为 1</li>
</ol>
<div class="admonition warning"><p class="admonition-title">注意  
</p><p><strong>使用删除虚拟系统序列号并不能确保你不会被 Ban。</strong></p>
</div>

<p><strong>虚拟系统屏蔽任天堂服务器</strong></p>
<ol>
<li>编辑 <code>atmosphere/config/system_settings.ini</code> 文件</li>
<li>取消 <code>enable_dns_mitm = u8!0x1</code> 前的注释</li>
<li>新建 <code>atmosphere/hosts/emummc.txt</code> 文件，文件内容如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Block Nintendo Servers</span></span><br><span class="line">127.0.0.1 *nintendo.*</span><br><span class="line">127.0.0.1 *nintendo-europe.com</span><br><span class="line">127.0.0.1 *nintendoswitch.*</span><br><span class="line">95.216.149.205 *conntest.nintendowifi.net</span><br><span class="line">95.216.149.205 *ctest.cdn.nintendo.net</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>打签名破解补丁：</strong></p>
<ol>
<li>下载<a href="https://github.com/ITotalJustice/patches">ITotalJustice&#x2F;patches</a>，直接解压到根目录，这样才能运行破解游戏。</li>
<li>编辑 <code>bootloader/hekate_ipl.ini</code> 文件，在[CFW (EMUMMC)] 下新增一行 <code>kip1patch=nosigchk</code>，我只在虚拟系统下开启破解补丁。</li>
</ol>
<div class="admonition warning"><p class="admonition-title">注意
</p><p><strong>大气层默认是不允许运行破解软件的，需要额外添加签名破解补丁才可以运行破解软件。</strong></p>
</div>

<div class="admonition info"><p class="admonition-title">关于启动虚拟系统的方式
</p><p><strong>如果使用Fusee方式引导进入大气层，则不需要添加<code>kip1patch=nosigchk</code>。</strong></p>
</div>

<p><strong>金手指下载：</strong></p>
<ol>
<li>进入<a href="https://gbatemp.net/download/cheat-codes-sxos-and-ams-main-cheat-file-updated.36311/">gbatemp.net</a>这个网址，下载金手指内容。</li>
<li>将下载的金手指内容解压到 <code>atmosphere/contents/</code> 目录</li>
<li>如果搜不到想要的金手指，也可以去下面几个网站碰碰运气<br>  <a href="http://www.hasheji.cn/forum-56-1.html">http://www.hasheji.cn/forum-56-1.html</a><br>  <a href="https://www.91tvg.com/forum-133-1.html">https://www.91tvg.com/forum-133-1.html</a><br>  <a href="https://github.com/ibnux/switch-cheat">另一个金手指发布地址</a></li>
</ol>
<p><strong>游戏下载：</strong></p>
<ol>
<li><a href="https://nxbrew.com/">nxbrew.com</a></li>
<li><a href="https://switch520.com/">switch520</a></li>
<li><a href="https://rpgonly.com/">rpgonly.com</a></li>
<li><a href="https://switchvip.com/">switchvip</a></li>
</ol>
<p>至此，所有工作都完成了，开机，享受你折腾的成果吧。</p>
<div class="admonition error"><p class="admonition-title">使用原则
</p><ul>
<li><strong>只在虚拟系统下安装破解游戏及 NSP 格式的插件</strong></li>
<li><strong>真实系统只插卡带玩或下载正版数字版游戏</strong></li>
<li><strong>真实系统可联机的游戏联机时不要开金手指，除非你有把握</strong></li>
<li><strong>真实系统可联机的游戏存档不要改的太过分，除非你有把握</strong></li>
<li><strong>按照此原则，任何系统随意联网，随意联机游戏，目前我还没被 ban，被 ban 了会在此更新，如被 ban 号或 ban 机，本人概不负责</strong></li>
</ul>
</div>

<h3 id="其他有用的插件"><a href="#其他有用的插件" class="headerlink" title="其他有用的插件"></a>其他有用的插件</h3><p><strong>[PC 端]</strong> <a href="https://github.com/developersu/ns-usbloader">NS-USBloader</a>：使用 USB 数据线连接 Switch 安装破解游戏时，需要在电脑上安装此软件，另外还需要 Java 运行环境<br><strong>[PC 端]</strong> <a href="https://github.com/eliboa/NxNandManager">NxNandManager</a>：虚拟系统占用了 32-64G 的 SD 卡空间，可以用这个软件缩小 USER 分区占用的空间 (只需要存游戏存档就可)，具体教程搜索互联网。<br><strong>[PC 端]</strong> <a href="https://github.com/julesontheroad/NSC_BUILDER/releases">NSCbuilder</a>: 魔改Rom神器，可以整合，转换，提取Rom，具体教程搜索互联网。<br><strong>[Switch 端 - 引导界面]</strong> <a href="https://github.com/shchmue/Lockpick_RCM">Lockpick_RCM</a>：用于提取本机密钥，在 Hekate 这个 BootLoader 的引导界面下使用<br><strong>[Switch 端]</strong> <a href="https://github.com/meganukebmp/Switch_90DNS_tester">90DNS Tester</a>：确定当前系统有无屏蔽任天堂服务器<br><strong>[Switch 端]</strong> <a href="https://github.com/XorTroll/Goldleaf">Goldleaf</a>：虚拟系统要和任天堂服务器确认后才能退出并删除不用的账号，这是做不到，金叶子还有这个附加功能可以删除账号<br><strong>[Switch 端]</strong> <a href="https://tinfoil.io/Download">Tinfoil</a>：游戏或者软件安装器，推荐。<br><strong>[Switch 端]</strong> <a href="https://github.com/rashevskyv/dbi/releases">DBI</a>：类似于3DS时代的FBI，游戏或者软件安装器，功能较为强大，推荐。<br><strong>[Switch 端]</strong> <a href="https://github.com/Huntereb/Awoo-Installer">Awoo-Installer</a>：另一款游戏或者软件安装器，同样功能强大，网上资源有时候装完了会用不了，我个人是多个安装器轮流安装，有时候一个安装器安装完资源不能正常运行，但换另外个安装器安装就可以，所以主机上可以多装几个安装器，推荐。<br><strong>[Switch 端]</strong> <a href="https://github.com/tomvita/EdiZon-SE">EdiZon-SE</a>：金手指软件，具体使用请自行搜索。</p>
<h3 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h3><p>等待 <a href="https://github.com/CTCaer/hekate">Hekate</a> 这个 BootLoader，<a href="https://github.com/Atmosphere-NX/Atmosphere/releases">大气层系统</a>，<a href="https://github.com/ITotalJustice/patches">破解补丁</a>更新，确保三者已支持最新系统，或直接等整合包 DeapSea 更新</p>
<ol>
<li>正确安装上述三者</li>
<li>真实系统：开机进入<code>Stock (SYSNAND)</code>，直接联网并更新，等待自动重启</li>
<li>虚拟系统：</li>
<li>下载固件：<a href="https://darthsternie.net/switch-firmwares/">https://darthsternie.net/switch-firmwares/</a></li>
<li>解压到根目录</li>
<li>开机进入 <code>CFW (EMUMMC)</code>, 进入相册 -&gt;Daybreak-&gt;Install-&gt; 选择固件目录，一路下一步，成功后自动重启。</li>
</ol>
<hr>
<blockquote>
<p>引用</p>
</blockquote>
<ol>
<li><a href="https://blog.kuretru.com/posts/4d5dc8ff/">OLED Switch 硬破后的折腾攻略</a></li>
<li><a href="https://www.marsshen.com/2022/05/29/switch-hack-terminology/">Switch硬件破解经验分享 - 术语篇</a></li>
</ol>
<div><h1>扩展阅读</h1><ul><li><a href="https://www.marsshen.com/posts/464772cb/">Switch硬件破解经验分享 - 破解焊接篇</a></li><li><a href="https://www.marsshen.com/posts/53cdbb65/">Switch硬件破解经验分享 - 破解芯片固件升级篇</a></li><li><a href="https://www.marsshen.com/posts/f96d7ec4/">Switch硬件破解经验分享 - 术语篇</a></li></ul></div>]]></content>
      <tags>
        <tag>原创</tag>
        <tag>switch硬破教程</tag>
        <tag>switch</tag>
      </tags>
  </entry>
</search>
